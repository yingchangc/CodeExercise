
// <summary>
/// 186. Reverse Words in a String II
/// https://leetcode.com/problems/reverse-words-in-a-string-ii/description/
///  Given an input string, reverse the string word by word.A word is defined as a sequence of non-space characters.
/// 
/// The input string does not contain leading or trailing spaces and the words are always separated by a single space.
/// 
/// For example,
/// Given s = "the sky is blue",
/// return "blue is sky the".
/// 
/// sol:
/// 
/// step1 mirror all "eulb si yks eht"
/// step2 mirror each word    note: can mirror space
// step 2 rotate each word

[code]
int len = str.Length;
int left = 0;
int right = 0;
while (left < len)
{
    if (right == len || str[right] == ' ')
    {
        Rotate(str, left, right - 1);

        // reset left and right
        right = right + 1;   // skip curr space
        left = right;
    }
    else
    {
        right++;
    }
}




/// <summary>
/// 680
/// https://leetcode.com/problems/valid-palindrome-ii/description/
/// Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.
///Example 1:
///Input: "aba"
///Output: True
///Example 2:
///Input: "abca"
///Output: True
///Explanation: You could delete the character 'c'.
///Note:
///The string will only contain lowercase characters a-z.The maximum length of the string is 50000.
///
/// Sol:
/// 
/// check if curr string can be palindrome.
/// if not, remove left char || remove right char and see

[code]
if (!hasMismatch)
{
    return true;
}
else
{
    return simpleValidPalindrome(s.Substring(left, (right - left)))
        || simpleValidPalindrome(s.Substring(left + 1, (right - left)));



/// <summary>
/// https://www.lintcode.com/problem/implement-strstr/description
/// 13. Implement strStr()
/// For a given source string and a target string, you should output the first index(from 0) of target string in source string.
/// 
/// If target does not exist in source, just return -1.
/// 
/// Example
/// If source = "source" and target = "target", return -1.
/// 
/// If source = "abcdabcdefg" and target = "bcd", return 1.
///  
     Sol: corner condition like source or target is null

O(n^2)

for(int i=0; i <= (lenSource-lenTarget); i++)
{
    if (containsTarget(source, target, i, lenTarget))
    {
        return i;
    }
}

(O(M+N))

Sol: use hash  and walk through source until find the same len of the target and compare with target hash
(1)first to find target (smaller string) hash
foreach (char c in target)
{
    targetHash = (targetHash * 31 + c) % HashSlots;
}

(2) 
if i > target.length, we need to substract (-) the highest bit by follow hash and prepare to new lower bit to add to hash
get higest bit
for(int i = 1; i <=targetLen; i++)
{
    hash = (hash * 31) % HashSlots;
}


// curr len is > target, need to remove high bit
for (int i = 0; i < slen; i++)
{
    // (a*31*31 + b*31 + c)  % 5
    sourceSubStrHash = (sourceSubStrHash * 31 + source[i]) % HashSlots;

    // now we have full length of target, check if first match. 
    if (i==(target.Length-1) && sourceSubStrHash == targetHash)
    {
        return i - target.Length + 1;
    }
    // abc  + d,  remove the highest hash so we can add a newer low bit to hash (keep the same lenght as target) 
    if (i >= target.Length)
    {

        // substract the highest bit number
        //sourceSubStrHash -= ((source[i-targetlen] * 31 ^ (target.Length))%HashSlots);    // might overflow

        sourceSubStrHash -= ((source[i-target.Length] * highestpower)%HashSlots);

        if (sourceSubStrHash < 0)
        {
            sourceSubStrHash += HashSlots;
        }

        if (sourceSubStrHash == targetHash)
        {
            // need to double confirm with reach char compare, to prevent hash collision
            if (source.Substring(i-target.Length+1, target.Length).Equals(target) )
            {
                return i - target.Length + 1;
            }                
        }

    }
}



//235
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
// O(sqrt(N))
[CODE]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime
{
    while (num%i ==0)
    {
        ans.Add(i);
        num /= i;
    }
}

if (num > 1)
{
    ans.Add(num);
}



/// 50. Pow(x, n)
/// https://leetcode.com/problems/powx-n/description/
/// Implement pow(x, n), which calculates x raised to the power n (xn).
else if (n < 0)
{
    // yic
    //max 2147483647
    //min -2147483648
    if (n == Int32.MinValue)     
    {
        return MyPow(Math.Abs(1 / x), Int32.MaxValue);  // -2147483648  -> 2147483647   if - value, the final is positive
    }
    return MyPow(1 / x, -n);
}  

private double powerHelper(double x, int n)
{
    if (n == 1)
    {
        return x;
    }
    double half = powerHelper(x, n / 2);

    if (n%2 == 0)
    {
        return half * half;
    }

    return half * half * x;

}        