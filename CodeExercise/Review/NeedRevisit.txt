
// <summary>
/// 186. Reverse Words in a String II
/// https://leetcode.com/problems/reverse-words-in-a-string-ii/description/
///  Given an input string, reverse the string word by word.A word is defined as a sequence of non-space characters.
/// 
/// The input string does not contain leading or trailing spaces and the words are always separated by a single space.
/// 
/// For example,
/// Given s = "the sky is blue",
/// return "blue is sky the".
/// 
/// sol:
/// 
/// step1 mirror all "eulb si yks eht"
/// step2 mirror each word    note: can mirror space
// step 2 rotate each word

[code]
int len = str.Length;
int left = 0;
int right = 0;
while (left < len)
{
    if (right == len || str[right] == ' ')
    {
        Rotate(str, left, right - 1);

        // reset left and right
        right = right + 1;   // skip curr space
        left = right;
    }
    else
    {
        right++;
    }
}




/// <summary>
/// 680
/// https://leetcode.com/problems/valid-palindrome-ii/description/
/// Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.
///Example 1:
///Input: "aba"
///Output: True
///Example 2:
///Input: "abca"
///Output: True
///Explanation: You could delete the character 'c'.
///Note:
///The string will only contain lowercase characters a-z.The maximum length of the string is 50000.
///
/// Sol:
/// 
/// check if curr string can be palindrome.
/// if not, remove left char || remove right char and see

[code]
if (!hasMismatch)
{
    return true;
}
else
{
    return simpleValidPalindrome(s.Substring(left, (right - left)))
        || simpleValidPalindrome(s.Substring(left + 1, (right - left)));



/// <summary>
/// https://www.lintcode.com/problem/implement-strstr/description
/// 13. Implement strStr()
/// For a given source string and a target string, you should output the first index(from 0) of target string in source string.
/// 
/// If target does not exist in source, just return -1.
/// 
/// Example
/// If source = "source" and target = "target", return -1.
/// 
/// If source = "abcdabcdefg" and target = "bcd", return 1.
///  
     Sol: corner condition like source or target is null

O(n^2)

for(int i=0; i <= (lenSource-lenTarget); i++)
{
    if (containsTarget(source, target, i, lenTarget))
    {
        return i;
    }
}

(O(M+N))

Sol: use hash  and walk through source until find the same len of the target and compare with target hash
(1)first to find target (smaller string) hash
foreach (char c in target)
{
    targetHash = (targetHash * 31 + c) % HashSlots;
}

(2) 
if i > target.length, we need to substract (-) the highest bit by follow hash and prepare to new lower bit to add to hash
get higest bit
for(int i = 1; i <=targetLen; i++)
{
    hash = (hash * 31) % HashSlots;
}


// curr len is > target, need to remove high bit
for (int i = 0; i < slen; i++)
{
    // (a*31*31 + b*31 + c)  % 5
    sourceSubStrHash = (sourceSubStrHash * 31 + source[i]) % HashSlots;

    // now we have full length of target, check if first match. 
    if (i==(target.Length-1) && sourceSubStrHash == targetHash)
    {
        return i - target.Length + 1;
    }
    // abc  + d,  remove the highest hash so we can add a newer low bit to hash (keep the same lenght as target) 
    if (i >= target.Length)
    {

        // substract the highest bit number
        //sourceSubStrHash -= ((source[i-targetlen] * 31 ^ (target.Length))%HashSlots);    // might overflow

        sourceSubStrHash -= ((source[i-target.Length] * highestpower)%HashSlots);

        if (sourceSubStrHash < 0)
        {
            sourceSubStrHash += HashSlots;
        }

        if (sourceSubStrHash == targetHash)
        {
            // need to double confirm with reach char compare, to prevent hash collision
            if (source.Substring(i-target.Length+1, target.Length).Equals(target) )
            {
                return i - target.Length + 1;
            }                
        }

    }
}



//235
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
// O(sqrt(N))
[CODE]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime
{
    while (num%i ==0)
    {
        ans.Add(i);
        num /= i;
    }
}

if (num > 1)
{
    ans.Add(num);
}



/// 50. Pow(x, n)
/// https://leetcode.com/problems/powx-n/description/
/// Implement pow(x, n), which calculates x raised to the power n (xn).
else if (n < 0)
{
    // yic
    //max 2147483647
    //min -2147483648
    if (n == Int32.MinValue)     
    {
        return MyPow(Math.Abs(1 / x), Int32.MaxValue);  // -2147483648  -> 2147483647   if - value, the final is positive
    }
    return MyPow(1 / x, -n);
}  

private double powerHelper(double x, int n)
{
    if (n == 1)
    {
        return x;
    }
    double half = powerHelper(x, n / 2);

    if (n%2 == 0)
    {
        return half * half;
    }

    return half * half * x;

}       


/// lint 140 fast power
///  https://www.lintcode.com/problem/fast-power/description
///  Calculate the a^n % b where a, b and n are all 32bit integers.
///  For 2^31 % 3 = 2
[code]
hanle a=0  n = 0 case.
Then

long product = fastPowerSolver(a, b, n / 2);
product = (product * product) %b;
if (n%2 == 0)
{
    return (int)product;
}
return (int)((product * a) %b);


/// 585. Maximum Number in Mountain Sequence
/// https://www.lintcode.com/en/old/problem/maximum-number-in-mountain-sequence/
/// 
/// Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.
/// Example
/// Given nums = [1, 2, 4, 8, 6, 3] return 8
/// Given nums = [10, 9, 8, 7], return 10 
[code]
while((left + 1) < right)
{
    // must be at least 3 elem to check
    int mid = left + (right - left) / 2;

    if (nums[mid-1] < nums[mid] && nums[mid] > nums[mid+1])     // yic  check mid-1  mid mid+1   not left, right
    {
        return nums[mid];
    }
    else if (nums[mid-1] <= nums[mid])
    {
        left = mid;
    }
    else
    {
        right = mid;
    }
}
// when out, it must be on the left/right edge
return Math.Max(nums[left], nums[right]);



/// 153
/// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e.,  [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
case     4 5 6 [0] "1" 2 3
case     4 5 6 [7] 8 9 "2"

/// Find the minimum element.
/// use binary search, and use "midV vs arr[right]""
///   smaller => go left to  get smallest,  bigger => go right
[code]
while((left +1) < right)
{
    int mid = left + (right - left) / 2;

    // yic  find smallest, check  mid and right
    // mid < right  (ascending),  go left to fiind min
    if (nums[mid] <= nums[right])
    {
        right = mid;
    }
    else
    {
        // 3 [4] 5 2
        left = mid;
    }
}

return nums[left] < nums[right] ? nums[left] : nums[right];



/// <summary>
/// 33. Search in Rotated Sorted Array
/// https://leetcode.com/problems/search-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e., [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
/// You are given a target value to search.If found in the array return its index, otherwise return -1.
/// 
/// You may assume no duplicate exists in the array.
case     4 5 6 [0] 1 2 3
case     4 5 6 [7] 8 9 2
[code]
while(left +1 < right)
{
    int mid = left + (right - left)/2;
    if (nums[mid] == target)
    {
        return mid;
    }
    // ascendint region
    if (nums[mid] < nums[right])
    {
        if (nums[mid] <= target && target <= nums[right])
        {
            left = mid;
        }
        else
        {
            right = mid;
        }
    }
    else
    {
        //3 4 [5] 6 1
        if (nums[left] <= target && target <= nums[mid])
        {
            right = mid;
        }
            else
        {
            left = mid;
        }
    }

}

if (nums[left] == target)
{
    return left;
}
else if (nums[right] == target)
{
    return right;
}
return -1;



//235
//Prime Factorization
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
[code]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime



/// 215. Kth Largest Element in an Array
/// https://leetcode.com/problems/kth-largest-element-in-an-array/description/
/// Find the kth largest element in an unsorted array. Note that it is the 
/// kth largest element in the sorted order, not the kth distinct element.
/// 
/// Example 1:
/// 
/// Input: [3,2,1,5,6,4]
///         and k = 2
/// Output: 5
/// Example 2:

[code]   k is the kIndex (0 based) not kth


if (start >= end)
{
    return nums[start];
}
int left = start;
int right = end;

int pivot = nums[start + (end - start) / 2];

while(left <= right)
{
    while(left <= right && nums[left] > pivot)
    {
        left++;
    }
    while (left <= right && nums[right] < pivot)
    {
        right--;
    }

    if (left <= right)
    {
        swap(nums, left++, right--);
    }
}

if (start <= k && k <= right)
{
    return SelectionSort(nums, k, start, right);
}
else if (left <= k && k<=end)
{
    return SelectionSort(nums, k, left, end);
}
else
{
    return nums[(left + right) / 2];
}



/// <summary>
/// 228. Middle of Linked List

/// https://www.lintcode.com/problem/middle-of-linked-list/description
/// Given 1->2->3, return the node with value 2.
/// Given 1->2, return the node with value 1.
[code]  fast.next.next != null to prevent move on for odd case
 
while (fast!=null && fast.next !=null && fast.next.next!=null)
{
    slow = slow.next;
    fast = fast.next.next;
}


/// lint 57. 3Sum
///https://www.lintcode.com/problem/3sum/description
///Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in 
///the array which gives the sum of zero.
///Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
///The solution set must not contain duplicate triplets.
///
/// For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:
/// (-1, 0, 1)
/// (-1, -1, 2)     
/// 
/// sol:
/// 
/// cannot use hashset as it does not rember the index and if it has appear before,
/// so use 2 pointers,  if first number exist, go right
///  if second number (after add to answer) exists before, go right

[code]
 // sort for the ans requirement (list to be ascending)
Array.Sort(numbers);
int len = numbers.Length;

List<List<int>> ans = new List<List<int>>();

for (int i =0; i <len-2; i++)
{
    if (i > 0 && numbers[i]==numbers[i-1])
    {
        continue;

        // YIC (numbers[i-1], numbers[i]), numbers[i+1]     if num i-1  == num i, i-1 has done all the possible combination
    }

    // apply two sum
    int target = 0 - numbers[i];

    int left = i + 1;
    int right = len-1;

    while (left < right)
    {
        if ((numbers[left] + numbers[right]) == target)
        {
            ans.Add(new List<int>() { numbers[i], numbers[left], numbers[right] });

            left++;
                        
            // yic Note: after add to ans, need to keep go right to de-duplicate   [1,1,1],1  target =3
            while (left < len && numbers[left] == numbers[left-1])
            {
                //just need to move left, because dup right cannot fullfil after
                left++;
            }
        }
        else if ((numbers[left] + numbers[right]) < target)
        {
            //yic just need to move left
            left++;
        }
        else
        {
            right--;
        }

    }
}



 609. Two Sum - Less than or equal to target
/// https://www.lintcode.com/en/old/problem/two-sum-less-than-or-equal-to-target/
/// Given an array of integers, find how many pairs in the array such that their sum is less than or equal to a specific target number.
/// Please return the number of pairs.
/// Have you met this question in a real interview?
/// Example
/// Given nums = [2, 7, 11, 15], target = 24.
/// Return 5. 
//  2 + 7 < 24
//  2 + 11 < 24
//  2 + 15 < 24
//  7 + 11 < 24
//  7 + 15 < 25

/// sol:
/// 
///  use 2 pointers
/// 
///      [i]    j
///      
//   start from   i = j-1, and find the first index that (nums[j]+nums[i]) <=target
///  at lease 0~i should also be able to count as valid (because is even lower after sort)
[code]

Array.Sort(nums);   // sort from small to large
while (left < right)
{
    if (nums[left] + nums[right] <= target)
    {
        ans += (right - left);   // yic  means, [left ...-> (right    will be smaller as well   ex.  [3]  4 5  6 [7]   target 3+7=  10,  means [3]+6  [3]+5 will be smaller, and 
                                    //  next step we move left [3], so won't have duplicate  
        left++;
    }
    else
    {
        right--;
    }
}

 /// <summary>
/// 443. Two Sum - Greater than target
/// https://www.lintcode.com/problem/two-sum-greater-than-target/description
/// Given an array of integers, find how many pairs in the array such that their sum is bigger than a specific target number. 
/// Please return the number of pairs.
///Example
///Given numbers = [2, 7, 11, 15], target = 24. Return 1. (11 + 15 is the only pair)
[code]
while(left < right)
{
    if (nums[left] + nums[right] > target)
    {
        ans += (right - left);    // yic means [left  .... + (right will be also greater   ex.  3  4 5  6 [7]   target  3+[7] =10  
                                    //means 4+[7]  5+[7] will be greater as well,  next step we move left [7], so won't have duplicate  
        right--;
    }
    else
    {
        left++;
    }              
}


/// 200. Number of Islands
/// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed 
/// by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
[code]

 for (int j = 0; j < m; j++)
{
    for (int i = 0; i < n; i++)
    {
        if (grid[j, i] == '1' && visited[j, i] == false)
        {
            // go to BFS and mark visited
            BFSHelper(grid, visited, m, n, i, j);
            numOFIsland++;
        }
    }
}

 private void BFSHelper(char[,] grid, bool[,] visited, int m, int n, int i, int j)
{
    Queue<Location> stk = new Queue<Location>();
    stk.Enqueue(new Location(i, j));

    visited[j, i] = true;
    // need to look for 4 dirs, because we rely on all must be visited in a BFS helper,  each push can be from all dirs
    List<Location> deltas = new List<Location>() { new Location(1, 0), new Location(-1, 0), new Location(0, 1), new Location(0, -1) };

    while (stk.Count > 0)
    {
        var loc = stk.Dequeue();

        foreach (var delta in deltas)
        {
            int nx = loc.x + delta.x;
            int ny = loc.y + delta.y;
            if ((nx >= 0 && nx < n) && (ny >= 0 && ny < m) && grid[ny, nx] == '1' && visited[ny, nx] == false)  // not yet visited land
            {
                visited[ny, nx] = true;
                stk.Enqueue(new Location(nx, ny));
            }
        }
    }
}


/// 207. Course Schedule
/// https://leetcode.com/problems/course-schedule/description/
/// There are a total of n courses you have to take, labeled from 0 to n-1.

/// Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
/// 
/// Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
/// Example:
/// 
/// Input: 2, [[1,0],[0,1]]
/// Output: false
sol:
// (1) compute the inbound count and build child graph (so that we can traverse to next child)
Dictionary<int, int> inLookup = new Dictionary<int, int>();   // node , inbound count
Dictionary<int, List<int>> childLookup = new Dictionary<int, List<int>>();   // parent-> children
// (2) put no inbound to queue
 for (int i = 0; i < numCourses; i++)
{
    if (!inbound.ContainsKey(i))
    {
        ans.Add(i);
        queue.Enqueue(i);
    }
}

// (3) traverse to next course, --child inbound, 0 then put to queue, finish when queue empty
    int finishCount = 0;
    while (queue.Count > 0)
    {
        int curr = queue.Dequeue();  // 0  root
        finishCount++;
        if (childLookup.ContainsKey(curr))   // yic  prevent the last node  no child exception
        {
            var ListNextCourses = childLookup[curr];
            foreach (int nxt in ListNextCourses)
            {
                inLookup[nxt]--;

                // new root node found
                if (inLookup[nxt] == 0)
                {
                    queue.Enqueue(nxt);  // only no pre can insert to queue
                }
            }
        }
    }

    return finishCount == numCourses;



/// lint 611 Knight Shortest Path
/// https://www.lintcode.com/problem/knight-shortest-path/description
/// Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.
/// Return -1 if knight can not reached.
/// 
/// If the knight is at (x, y), he can get to the following positions in one step:
/// (x + 1, y + 2)
/// (x + 1, y - 2)
/// (x - 1, y + 2)
/// (x - 1, y - 2)
/// (x + 2, y + 1)
/// (x + 2, y - 1)
/// (x - 2, y + 1)
/// (x - 2, y - 1)
//Sol :use BFS level order to get min steps count
[code]
step = 0;
while(queue.Count > 0)
{
    int levelSize = queue.Count;

    for (int i = 0; i <levelSize; i++)
    {
        var curr = queue.Dequeue();

        if (curr.x == destination.x && curr.y == destination.y)
        {
            return steps;    // yic check  source == destination
        }

        // look for 8 surrandings 
        foreach (var deltaP in deltas)
        {
            var newPoint = new Point(curr.x + deltaP.x, curr.y + deltaP.y);

            if (newPoint.x >= 0 && newPoint.x < xLen && newPoint.y >= 0 && newPoint.y < yLen
                && grid[newPoint.x, newPoint.y] == false   // no block
                && visited[newPoint.x, newPoint.y] == false)
            {
                visited[newPoint.x, newPoint.y] = true;   //yic  true first
                queue.Enqueue(newPoint);
            }
        }

    }

    steps++;  // yic, step ++ here   ex, source==dest
}


/// 444. Sequence Reconstruction
/// https://leetcode.com/problems/sequence-reconstruction/description/
/// Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a 
/// permutation of the integers from 1 to n, with 1 ≤ n ≤ 10^4. Reconstruction means building a shortest common supersequence 
/// of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). 
/// Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.
/// Example 1:
/// 
/// Input:
/// org: [1,2,3], seqs: [[1,2,3],[1,3]]
sol:
 use topological sort. None anyone seq can bigger than count 2.
 if unique. 
 // early terminate when more than 1 choices
 while(queue.Count == 1)

 if (org.Length == tSortArr.Count && inbound.Keys.Count == org.Length)   //yic make sure inbound all node are calculated


/// 133 Clone Graph
/// https://leetcode.com/problems/clone-graph/description/
/// 
/// Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
/// 
/// Nodes are labeled uniquely.
/// 
/// We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
/// As an example, consider the serialized graph {
///             0,1,2#1,2#2,2}.
/// 
/// The graph has a total of three nodes, and therefore contains three parts as separated by #.
/// 
/// First node is labeled as 0.Connect node 0 to both nodes 1 and 2.
/// Second node is labeled as 1.Connect node 1 to node 2.
/// Third node is labeled as 2.Connect node 2 to node 2(itself), thus forming a self-cycle.
/// Sol:
///  first copy node by bfs to dictionary<orig, new>
/// for each dic keys, find orig neighbors and assign coped neighbor to new node 
[code]
Queue<UndirectedGraphNode> queue = new Queue<UndirectedGraphNode>();
Dictionary<UndirectedGraphNode, UndirectedGraphNode> lookup = new Dictionary<UndirectedGraphNode, UndirectedGraphNode>();  // old, new
queue.Enqueue(node);
lookup.Add(node, new UndirectedGraphNode(node.label));


 // link new neighbors by old neighbors
foreach(UndirectedGraphNode n in lookup.Keys)
{
    var copiedNode = lookup[n];
    foreach(var neighbor in n.neighbors)
    {
        copiedNode.neighbors.Add(lookup[neighbor]);
    }
}