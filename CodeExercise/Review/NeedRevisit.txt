
// <summary>
/// 186. Reverse Words in a String II
/// https://leetcode.com/problems/reverse-words-in-a-string-ii/description/
///  Given an input string, reverse the string word by word.A word is defined as a sequence of non-space characters.
/// 
/// The input string does not contain leading or trailing spaces and the words are always separated by a single space.
/// 
/// For example,
/// Given s = "the sky is blue",
/// return "blue is sky the".
/// 
/// sol:
/// 
/// step1 mirror all "eulb si yks eht"
/// step2 mirror each word    note: can mirror space
// step 2 rotate each word

[code]
int len = str.Length;
int left = 0;
int right = 0;
while (left < len)
{
    if (right == len || str[right] == ' ')
    {
        Rotate(str, left, right - 1);

        // reset left and right
        right = right + 1;   // skip curr space
        left = right;
    }
    else
    {
        right++;
    }
}




/// <summary>
/// 680
/// https://leetcode.com/problems/valid-palindrome-ii/description/
/// Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.
///Example 1:
///Input: "aba"
///Output: True
///Example 2:
///Input: "abca"
///Output: True
///Explanation: You could delete the character 'c'.
///Note:
///The string will only contain lowercase characters a-z.The maximum length of the string is 50000.
///
/// Sol:
/// 
/// check if curr string can be palindrome.
/// if not, remove left char || remove right char and see

[code]
if (!hasMismatch)
{
    return true;
}
else
{
    return simpleValidPalindrome(s.Substring(left, (right - left)))
        || simpleValidPalindrome(s.Substring(left + 1, (right - left)));



/// <summary>
/// https://www.lintcode.com/problem/implement-strstr/description
/// 13. Implement strStr()
/// For a given source string and a target string, you should output the first index(from 0) of target string in source string.
/// 
/// If target does not exist in source, just return -1.
/// 
/// Example
/// If source = "source" and target = "target", return -1.
/// 
/// If source = "abcdabcdefg" and target = "bcd", return 1.
///  
     Sol: corner condition like source or target is null

O(n^2)

for(int i=0; i <= (lenSource-lenTarget); i++)
{
    if (containsTarget(source, target, i, lenTarget))
    {
        return i;
    }
}

(O(M+N))

Sol: use hash  and walk through source until find the same len of the target and compare with target hash
(1)first to find target (smaller string) hash
foreach (char c in target)
{
    targetHash = (targetHash * 31 + c) % HashSlots;
}

(2) 
if i > target.length, we need to substract (-) the highest bit by follow hash and prepare to new lower bit to add to hash
get higest bit
for(int i = 1; i <=targetLen; i++)
{
    hash = (hash * 31) % HashSlots;
}


// curr len is > target, need to remove high bit
for (int i = 0; i < slen; i++)
{
    // (a*31*31 + b*31 + c)  % 5
    sourceSubStrHash = (sourceSubStrHash * 31 + source[i]) % HashSlots;

    // now we have full length of target, check if first match. 
    if (i==(target.Length-1) && sourceSubStrHash == targetHash)
    {
        return i - target.Length + 1;
    }
    // abc  + d,  remove the highest hash so we can add a newer low bit to hash (keep the same lenght as target) 
    if (i >= target.Length)
    {

        // substract the highest bit number
        //sourceSubStrHash -= ((source[i-targetlen] * 31 ^ (target.Length))%HashSlots);    // might overflow

        sourceSubStrHash -= ((source[i-target.Length] * highestpower)%HashSlots);

        if (sourceSubStrHash < 0)
        {
            sourceSubStrHash += HashSlots;
        }

        if (sourceSubStrHash == targetHash)
        {
            // need to double confirm with reach char compare, to prevent hash collision
            if (source.Substring(i-target.Length+1, target.Length).Equals(target) )
            {
                return i - target.Length + 1;
            }                
        }

    }
}



//235
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
// O(sqrt(N))
[CODE]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime
{
    while (num%i ==0)
    {
        ans.Add(i);
        num /= i;
    }
}

if (num > 1)
{
    ans.Add(num);
}



/// 50. Pow(x, n)
/// https://leetcode.com/problems/powx-n/description/
/// Implement pow(x, n), which calculates x raised to the power n (xn).
else if (n < 0)
{
    // yic
    //max 2147483647
    //min -2147483648
    if (n == Int32.MinValue)     
    {
        return MyPow(Math.Abs(1 / x), Int32.MaxValue);  // -2147483648  -> 2147483647   if - value, the final is positive
    }
    return MyPow(1 / x, -n);
}  

private double powerHelper(double x, int n)
{
    if (n == 1)
    {
        return x;
    }
    double half = powerHelper(x, n / 2);

    if (n%2 == 0)
    {
        return half * half;
    }

    return half * half * x;

}       


/// lint 140 fast power
///  https://www.lintcode.com/problem/fast-power/description
///  Calculate the a^n % b where a, b and n are all 32bit integers.
///  For 2^31 % 3 = 2
[code]
hanle a=0  n = 0 case.
Then

long product = fastPowerSolver(a, b, n / 2);
product = (product * product) %b;
if (n%2 == 0)
{
    return (int)product;
}
return (int)((product * a) %b);


/// 585. Maximum Number in Mountain Sequence
/// https://www.lintcode.com/en/old/problem/maximum-number-in-mountain-sequence/
/// 
/// Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.
/// Example
/// Given nums = [1, 2, 4, 8, 6, 3] return 8
/// Given nums = [10, 9, 8, 7], return 10 
[code]
while((left + 1) < right)
{
    // must be at least 3 elem to check
    int mid = left + (right - left) / 2;

    if (nums[mid-1] < nums[mid] && nums[mid] > nums[mid+1])     // yic  check mid-1  mid mid+1   not left, right
    {
        return nums[mid];
    }
    else if (nums[mid-1] <= nums[mid])
    {
        left = mid;
    }
    else
    {
        right = mid;
    }
}
// when out, it must be on the left/right edge
return Math.Max(nums[left], nums[right]);



/// 153
/// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e.,  [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
case     4 5 6 [0] "1" 2 3
case     4 5 6 [7] 8 9 "2"

/// Find the minimum element.
/// use binary search, and use "midV vs arr[right]""
///   smaller => go left to  get smallest,  bigger => go right
[code]
while((left +1) < right)
{
    int mid = left + (right - left) / 2;

    // yic  find smallest, check  mid and right
    // mid < right  (ascending),  go left to fiind min
    if (nums[mid] <= nums[right])
    {
        right = mid;
    }
    else
    {
        // 3 [4] 5 2
        left = mid;
    }
}

return nums[left] < nums[right] ? nums[left] : nums[right];



/// <summary>
/// 33. Search in Rotated Sorted Array
/// https://leetcode.com/problems/search-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e., [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
/// You are given a target value to search.If found in the array return its index, otherwise return -1.
/// 
/// You may assume no duplicate exists in the array.
case     4 5 6 [0] 1 2 3
case     4 5 6 [7] 8 9 2
[code]
while(left +1 < right)
{
    int mid = left + (right - left)/2;
    if (nums[mid] == target)
    {
        return mid;
    }
    // ascendint region
    if (nums[mid] < nums[right])
    {
        if (nums[mid] <= target && target <= nums[right])
        {
            left = mid;
        }
        else
        {
            right = mid;
        }
    }
    else
    {
        //3 4 [5] 6 1
        if (nums[left] <= target && target <= nums[mid])
        {
            right = mid;
        }
            else
        {
            left = mid;
        }
    }

}

if (nums[left] == target)
{
    return left;
}
else if (nums[right] == target)
{
    return right;
}
return -1;



//235
//Prime Factorization
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
[code]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime



/// 215. Kth Largest Element in an Array
/// https://leetcode.com/problems/kth-largest-element-in-an-array/description/
/// Find the kth largest element in an unsorted array. Note that it is the 
/// kth largest element in the sorted order, not the kth distinct element.
/// 
/// Example 1:
/// 
/// Input: [3,2,1,5,6,4]
///         and k = 2
/// Output: 5
/// Example 2:

[code]   k is the kIndex (0 based) not kth


if (start >= end)
{
    return nums[start];
}
int left = start;
int right = end;

int pivot = nums[start + (end - start) / 2];

while(left <= right)
{
    while(left <= right && nums[left] > pivot)
    {
        left++;
    }
    while (left <= right && nums[right] < pivot)
    {
        right--;
    }

    if (left <= right)
    {
        swap(nums, left++, right--);
    }
}

if (start <= k && k <= right)
{
    return SelectionSort(nums, k, start, right);
}
else if (left <= k && k<=end)
{
    return SelectionSort(nums, k, left, end);
}
else
{
    return nums[(left + right) / 2];
}



/// <summary>
/// 228. Middle of Linked List

/// https://www.lintcode.com/problem/middle-of-linked-list/description
/// Given 1->2->3, return the node with value 2.
/// Given 1->2, return the node with value 1.
[code]  fast.next.next != null to prevent move on for odd case
 
while (fast!=null && fast.next !=null && fast.next.next!=null)
{
    slow = slow.next;
    fast = fast.next.next;
}


/// lint 57. 3Sum
///https://www.lintcode.com/problem/3sum/description
///Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in 
///the array which gives the sum of zero.
///Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
///The solution set must not contain duplicate triplets.
///
/// For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:
/// (-1, 0, 1)
/// (-1, -1, 2)     
/// 
/// sol:
/// 
/// cannot use hashset as it does not rember the index and if it has appear before,
/// so use 2 pointers,  if first number exist, go right
///  if second number (after add to answer) exists before, go right

[code]
 // sort for the ans requirement (list to be ascending)
Array.Sort(numbers);
int len = numbers.Length;

List<List<int>> ans = new List<List<int>>();

for (int i =0; i <len-2; i++)
{
    if (i > 0 && numbers[i]==numbers[i-1])
    {
        continue;

        // YIC (numbers[i-1], numbers[i]), numbers[i+1]     if num i-1  == num i, i-1 has done all the possible combination
    }

    // apply two sum
    int target = 0 - numbers[i];

    int left = i + 1;
    int right = len-1;

    while (left < right)
    {
        if ((numbers[left] + numbers[right]) == target)
        {
            ans.Add(new List<int>() { numbers[i], numbers[left], numbers[right] });

            left++;
                        
            // yic Note: after add to ans, need to keep go right to de-duplicate   [1,1,1],1  target =3
            while (left < len && numbers[left] == numbers[left-1])
            {
                //just need to move left, because dup right cannot fullfil after
                left++;
            }
        }
        else if ((numbers[left] + numbers[right]) < target)
        {
            //yic just need to move left
            left++;
        }
        else
        {
            right--;
        }

    }
}



 609. Two Sum - Less than or equal to target
/// https://www.lintcode.com/en/old/problem/two-sum-less-than-or-equal-to-target/
/// Given an array of integers, find how many pairs in the array such that their sum is less than or equal to a specific target number.
/// Please return the number of pairs.
/// Have you met this question in a real interview?
/// Example
/// Given nums = [2, 7, 11, 15], target = 24.
/// Return 5. 
//  2 + 7 < 24
//  2 + 11 < 24
//  2 + 15 < 24
//  7 + 11 < 24
//  7 + 15 < 25

/// sol:
/// 
///  use 2 pointers
/// 
///      [i]    j
///      
//   start from   i = j-1, and find the first index that (nums[j]+nums[i]) <=target
///  at lease 0~i should also be able to count as valid (because is even lower after sort)
[code]

Array.Sort(nums);   // sort from small to large
while (left < right)
{
    if (nums[left] + nums[right] <= target)
    {
        ans += (right - left);   // yic  means, [left ...-> (right    will be smaller as well   ex.  [3]  4 5  6 [7]   target 3+7=  10,  means [3]+6  [3]+5 will be smaller, and 
                                    //  next step we move left [3], so won't have duplicate  
        left++;
    }
    else
    {
        right--;
    }
}

 /// <summary>
/// 443. Two Sum - Greater than target
/// https://www.lintcode.com/problem/two-sum-greater-than-target/description
/// Given an array of integers, find how many pairs in the array such that their sum is bigger than a specific target number. 
/// Please return the number of pairs.
///Example
///Given numbers = [2, 7, 11, 15], target = 24. Return 1. (11 + 15 is the only pair)
[code]
while(left < right)
{
    if (nums[left] + nums[right] > target)
    {
        ans += (right - left);    // yic means [left  .... + (right will be also greater   ex.  3  4 5  6 [7]   target  3+[7] =10  
                                    //means 4+[7]  5+[7] will be greater as well,  next step we move left [7], so won't have duplicate  
        right--;
    }
    else
    {
        left++;
    }              
}


/// 200. Number of Islands
/// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed 
/// by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
[code]

 for (int j = 0; j < m; j++)
{
    for (int i = 0; i < n; i++)
    {
        if (grid[j, i] == '1' && visited[j, i] == false)
        {
            // go to BFS and mark visited
            BFSHelper(grid, visited, m, n, i, j);
            numOFIsland++;
        }
    }
}

 private void BFSHelper(char[,] grid, bool[,] visited, int m, int n, int i, int j)
{
    Queue<Location> stk = new Queue<Location>();
    stk.Enqueue(new Location(i, j));

    visited[j, i] = true;
    // need to look for 4 dirs, because we rely on all must be visited in a BFS helper,  each push can be from all dirs
    List<Location> deltas = new List<Location>() { new Location(1, 0), new Location(-1, 0), new Location(0, 1), new Location(0, -1) };

    while (stk.Count > 0)
    {
        var loc = stk.Dequeue();

        foreach (var delta in deltas)
        {
            int nx = loc.x + delta.x;
            int ny = loc.y + delta.y;
            if ((nx >= 0 && nx < n) && (ny >= 0 && ny < m) && grid[ny, nx] == '1' && visited[ny, nx] == false)  // not yet visited land
            {
                visited[ny, nx] = true;
                stk.Enqueue(new Location(nx, ny));
            }
        }
    }
}


/// 207. Course Schedule
/// https://leetcode.com/problems/course-schedule/description/
/// There are a total of n courses you have to take, labeled from 0 to n-1.

/// Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
/// 
/// Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
/// Example:
/// 
/// Input: 2, [[1,0],[0,1]]
/// Output: false
sol:
// (1) compute the inbound count and build child graph (so that we can traverse to next child)
Dictionary<int, int> inLookup = new Dictionary<int, int>();   // node , inbound count
Dictionary<int, List<int>> childLookup = new Dictionary<int, List<int>>();   // parent-> children
// (2) put no inbound to queue
 for (int i = 0; i < numCourses; i++)
{
    if (!inbound.ContainsKey(i))
    {
        ans.Add(i);
        queue.Enqueue(i);
    }
}

// (3) traverse to next course, --child inbound, 0 then put to queue, finish when queue empty
    int finishCount = 0;
    while (queue.Count > 0)
    {
        int curr = queue.Dequeue();  // 0  root
        finishCount++;
        if (childLookup.ContainsKey(curr))   // yic  prevent the last node  no child exception
        {
            var ListNextCourses = childLookup[curr];
            foreach (int nxt in ListNextCourses)
            {
                inLookup[nxt]--;

                // new root node found
                if (inLookup[nxt] == 0)
                {
                    queue.Enqueue(nxt);  // only no pre can insert to queue
                }
            }
        }
    }

    return finishCount == numCourses;



/// lint 611 Knight Shortest Path
/// https://www.lintcode.com/problem/knight-shortest-path/description
/// Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.
/// Return -1 if knight can not reached.
/// 
/// If the knight is at (x, y), he can get to the following positions in one step:
/// (x + 1, y + 2)
/// (x + 1, y - 2)
/// (x - 1, y + 2)
/// (x - 1, y - 2)
/// (x + 2, y + 1)
/// (x + 2, y - 1)
/// (x - 2, y + 1)
/// (x - 2, y - 1)
//Sol :use BFS level order to get min steps count
[code]
step = 0;
while(queue.Count > 0)
{
    int levelSize = queue.Count;

    for (int i = 0; i <levelSize; i++)
    {
        var curr = queue.Dequeue();

        if (curr.x == destination.x && curr.y == destination.y)
        {
            return steps;    // yic check  source == destination
        }

        // look for 8 surrandings 
        foreach (var deltaP in deltas)
        {
            var newPoint = new Point(curr.x + deltaP.x, curr.y + deltaP.y);

            if (newPoint.x >= 0 && newPoint.x < xLen && newPoint.y >= 0 && newPoint.y < yLen
                && grid[newPoint.x, newPoint.y] == false   // no block
                && visited[newPoint.x, newPoint.y] == false)
            {
                visited[newPoint.x, newPoint.y] = true;   //yic  true first
                queue.Enqueue(newPoint);
            }
        }

    }

    steps++;  // yic, step ++ here   ex, source==dest
}


/// 444. Sequence Reconstruction
/// https://leetcode.com/problems/sequence-reconstruction/description/
/// Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a 
/// permutation of the integers from 1 to n, with 1 ≤ n ≤ 10^4. Reconstruction means building a shortest common supersequence 
/// of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). 
/// Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.
/// Example 1:
/// 
/// Input:
/// org: [1,2,3], seqs: [[1,2,3],[1,3]]
sol:
 use topological sort. None anyone seq can bigger than count 2.
 if unique. 
 // early terminate when more than 1 choices
 while(queue.Count == 1)

 if (org.Length == tSortArr.Count && inbound.Keys.Count == org.Length)   //yic make sure inbound all node are calculated





/// 133 Clone Graph
/// https://leetcode.com/problems/clone-graph/description/
/// 
/// Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
/// 
/// Nodes are labeled uniquely.
/// 
/// We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
/// As an example, consider the serialized graph {
///             0,1,2#1,2#2,2}.
/// 
/// The graph has a total of three nodes, and therefore contains three parts as separated by #.
/// 
/// First node is labeled as 0.Connect node 0 to both nodes 1 and 2.
/// Second node is labeled as 1.Connect node 1 to node 2.
/// Third node is labeled as 2.Connect node 2 to node 2(itself), thus forming a self-cycle.
/// Sol:
///  first copy node by bfs to dictionary<orig, new>
/// for each dic keys, find orig neighbors and assign coped neighbor to new node 
[code]
Queue<UndirectedGraphNode> queue = new Queue<UndirectedGraphNode>();
Dictionary<UndirectedGraphNode, UndirectedGraphNode> lookup = new Dictionary<UndirectedGraphNode, UndirectedGraphNode>();  // old, new
queue.Enqueue(node);
lookup.Add(node, new UndirectedGraphNode(node.label));


 // link new neighbors by old neighbors
foreach(UndirectedGraphNode n in lookup.Keys)
{
    var copiedNode = lookup[n];
    foreach(var neighbor in n.neighbors)
    {
        copiedNode.neighbors.Add(lookup[neighbor]);
    }
}


 /// 624. Remove Substrings
/// https://www.lintcode.com/problem/remove-substrings/description
/// Given a string s and a set of n substrings.You are supposed to remove every instance of those n substrings 
/// from s so that s is of the minimum length and output this minimum length.
/// 
/// Example
/// Given s = ccdaabcdbb, substrs = ["ab", "cd"]
/// Return 2

[code]
if (visited.Contains(s))
{
    return;
}

minLen = Math.Min(s.Length, minLen);

foreach(string word in dict)
{
    if (s.Contains(word))
    {
        HashSet<string> shorterStrs = RemoveSubstr(s, word);
        foreach(string shorterStr in shorterStrs)
        {
            MinLengthHelper(shorterStr, dict);
        }
                                      
    }
}

visited.Add(s);




 /// 261 Graph Valid Tree
/// https://leetcode.com/problems/graph-valid-tree/description/
/// Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
/// 
///         For example:
/// 
/// Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.
/// 
/// Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
/// 
/// Note: you can assume that no duplicate edges will appear in edges.Since all edges are undirected, [0, 1] is the same as [1, 0]
///         and thus will not appear together in edges.
///         
/// Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path.”
/// 
/// 
/// Sol:
///  UnionFind when add a node their parent should not be the same initially,          
/// in case 2 , when [1,3] is added, found that 1  and 3 point to the same parent, which should not be the case for real tree
[code]
UnionFindGraphValidTree uf = new UnionFindGraphValidTree(n); // n nodes

for (int i = 0; i< numEdges; i++)
{
    int n1 = edges[i, 0];
    int n2 = edges[i, 1];

    int rootA = uf.Find(n1);
    int rootB = uf.Find(n2);

    if (rootA == rootB)
    {
        return false;
    }

    uf.Union(n1, n2);
}

return (uf.Count==1);   // yic for disjoin graph


 public int Find(int a)
{
    if (a != ufArray[a])
    {
        int topAncestor = Find(ufArray[a]);
        ufArray[a] = topAncestor;
    }
    return ufArray[a];
}



/// 431. Connected Component in Undirected Graph
/// https://www.lintcode.com/problem/connected-component-in-undirected-graph/description
/// Find the number connected component in the undirected graph. Each node in the graph contains a label and a list of its neighbors. (a connected component (or just component) of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.)
/// 
/// Example
/// Given graph:
/// 
/// A------B  C
///  \     |  | 
///   \    |  |
///    \   |  |
///     \  |  |
///       D   E
/// Return {A,B,D}, {C,E}. Since there are two connected component which is {A,B,D}, {C,E}

sol:  use HashSet<int> to find how many distinct nodes, then use UnionFind, since nodes are A, B, C  not 0 1 2 ..
need to use HashMap<char, char>  for node, parent in union



/// 110. Balanced Binary Tree
/// https://leetcode.com/problems/balanced-binary-tree/description/
/// Given a binary tree, determine if it is height-balanced.
[code]
if (root == null)
{
    return 0;
}

int leftPath = longestPath(root.left);
int rightPath = longestPath(root.right);

if (Math.Abs(leftPath - rightPath) > 1)
{
    isBalanceFalg = false;
}

return Math.Max(1+leftPath, 1+rightPath);



573. Build Post Office II
/// https://www.lintcode.com/problem/build-post-office-ii/description
/// Given a 2D grid, each cell is either a wall 2, an house 1 or empty 0 (the number zero, one, two), find a place to build a post office so that the 
/// sum of the distance from the post office to all the houses is smallest.
/// 
/// Return the smallest sum of distance.Return -1 if it is not possible.
Sol:
 /// BFS in each 0 location and compute the sum, find the min sum, Note: look for 4 directions
[code]
while(queue.Count > 0)
{
    int levelSize = queue.Count();

    for (int k = 0; k < levelSize; k++)
    {
        Location curr = queue.Dequeue();  // should be 0   empty
        foreach (var delta in deltas)
        {
            int nI = curr.i + delta.i;
            int nJ = curr.j + delta.j;

            if (nI < totalI && nI >= 0 && nJ < totalJ && nJ >= 0 && !visited[nI, nJ])  // yic  visited  is needed
            {
                if (grid[nI, nJ] == 0)    // empty, can walk to next position
                {
                    queue.Enqueue(new Location(nI, nJ));
                }
                else if (grid[nI, nJ] == 1)  // house
                {
                    sum += (step + 1);
                    numHouse--;
                }
                visited[nI, nJ] = true;
            }  
        }
    }
    step++;
}



// Binary Search Tree Removal
http://www.algolist.net/Data_structures/Binary_search_tree/Removal



/// <summary>
/// 79 
/// Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). 
/// If nums = [1,2,2], a solution is: 
///           [
///             [2],
///             [1],
///             [1,2,2],
///             [2,2],
///             [1,2],
///             []
///           ]
[code]
if (index >= nums.Length)
{
    List<int> copy = new List<int>(currPath);
    ans.Add(copy);
    return;
}

// add 
currPath.Add(nums[index]);
dfsHelper2(nums, index + 1, currPath, ans);
currPath.RemoveAt(currPath.Count -1);

// no add
int i = index + 1;
while (i < nums.Length && nums[i] == nums[i-1])
{
    i++;
}

dfsHelper2(nums, i, currPath, ans);



//235
//Prime Factorization
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
// O(sqrt(N))
// sol  for from 2 to sqrt(N)  + the leftover num   ( sqrt 34 is 5.   34/2 = 17)
[code]
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime
{
    while (num%i ==0)
    {
        ans.Add(i);
        num /= i;
    }
}

if (num > 1)
{
    ans.Add(num);
}



/// 140
/// Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words. 
///         Return all such possible sentences.
///         For example, given
/// s = "catsanddog",
/// dict = ["cat", "cats", "and", "sand", "dog"]. 
/// A solution is ["cats and dog", "cat sand dog"].
/// Sol:  don't forget memoizaiton

// think each return I want List<subString>,  be carefore for the whole word match case
[code]

private List<string> DFSHelper2(string s, int index, IList<string> wordDict, Dictionary<int, List<string>> visited)
{
    if (visited.ContainsKey(index))
    {
        return visited[index];
    }

    List<string> currAns = new List<string>();

    for (int i = index; i <s.Length; i++)
    {
        string substr = s.Substring(index, i - index + 1);
        if (wordDict.Contains(substr))
        {
            // reached last word
            if (i+1 >= s.Length)
            {
                currAns.Add(substr);
            }
            else
            {
                // not last word
                List<string> suffixStrs = DFSHelper2(s, i + 1, wordDict, visited);

                foreach (var suffix in suffixStrs)
                {
                    // only add to ans if suffix has something
                    currAns.Add(substr + " " + suffix);
                }
            }
                    
        }
    }

    visited.Add(index, currAns);

    return currAns;

}


/// https://leetcode.com/problems/wildcard-matching/description/
/// 
/// '?' Matches any single character.
/// '*' Matches any sequence of characters(including the empty sequence).
/// 
/// The matching should cover the entire input string (not partial).
// sol recursive,  be aware case   like   s:""  pattern: "**"   
[code]
private bool IsMatchHelper2(string s, string p, bool[,] visited,  bool[,] memo, int i, int j)
{
    int sLen = s.Length;
    int pLen = p.Length;
    if (i == sLen && j == pLen)  // both ran out
    {
        return true;
    }

    if (j == p.Length)   // yic: only pattern ran out
    {
        return false;
    }
    if (i == s.Length)  // yic s ran out
    {
        if (p[j] == '*')
        {
            return IsMatchHelper2(s, p, visited, memo, i, j + 1);  // match 0 case
        }
        return false;
    }

    if (visited[i,j])
    {
        return memo[i, j];
    }

    bool canMatch = false;

    if (s[i] == p[j])
    {
        canMatch = IsMatchHelper2(s, p, visited, memo, i + 1, j + 1);
    }
    else if (p[j] == '?')
    {
        canMatch = IsMatchHelper2(s, p, visited, memo, i + 1, j + 1);
    }
    else if (p[j] == '*')
    {
        canMatch = IsMatchHelper2(s, p, visited, memo, i, j + 1)   // match 0
                || IsMatchHelper2(s, p, visited, memo, i+1, j + 1)   // match 1
                || IsMatchHelper2(s, p, visited, memo, i+1, j);  // match many
    }
    else
    {
        //s[i]!=p[j]
        canMatch = false;
    }
    visited[i, j] = true;
    memo[i, j] = canMatch;

    return canMatch;
}


/// 10
/// https://leetcode.com/problems/regular-expression-matching/description/
/// '.' Matches any single character.
/// '*' Matches zero or more of the preceding element.
/// 
/// The matching should cover the entire input string (not partial).
private bool IsMatchHelper(string s, string p, bool [,] F, bool[,] visited, int i, int j)
{
    if (i < 0 & j < 0)
    {
        return true;
    }
    if (i < 0)
    {
        if (p[j] == '*')
        {
            return IsMatchHelper(s, p, F, visited, i, j-2);  // assume th patern is valid,   s""  p "a*"
        }
        else
        {
            return false;
        }
    }
    else if (j < 0)   // i != 0  & j==0
    {
        return false;
    }   

    if (visited[i,j])
    {
        return F[i, j];
    }

    if (s[i] == p[j])
    {
        F[i, j] = IsMatchHelper(s, p, F, visited, i - 1, j - 1);
    }
    else if (p[j] == '.')   // match any single char
    {
        F[i, j] = IsMatchHelper(s, p, F, visited, i - 1, j - 1);
    }
    else if (p[j] == '*')
    {
        bool match0 = IsMatchHelper(s, p, F, visited, i, j - 2);   // match 0 case
        bool match1 = false;
        bool match2 = false;

        if (p[j-1] == s[i] || p[j-1] == '.')   // yic: remember char need to match before going down
        {
            match1 = IsMatchHelper(s, p, F, visited, i - 1, j - 2); // match 1 case    abc   <-- ab.*  | abc*
            match2 = IsMatchHelper(s, p, F, visited, i - 1, j);   // match multi case
        }
                

        F[i, j] = match0 || match1 || match2;
    }
    else
    {
        F[i, j] = false;
    }

    visited[i, j] = true;

    return F[i, j];
}