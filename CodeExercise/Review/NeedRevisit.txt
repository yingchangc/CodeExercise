
// <summary>
/// 186. Reverse Words in a String II
/// https://leetcode.com/problems/reverse-words-in-a-string-ii/description/
///  Given an input string, reverse the string word by word.A word is defined as a sequence of non-space characters.
/// 
/// The input string does not contain leading or trailing spaces and the words are always separated by a single space.
/// 
/// For example,
/// Given s = "the sky is blue",
/// return "blue is sky the".
/// 
/// sol:
/// 
/// step1 mirror all "eulb si yks eht"
/// step2 mirror each word    note: can mirror space
// step 2 rotate each word

[code]
Rotate(str, 0, str.Length - 1);
Console.WriteLine(str);
// step 2 rotate each word
int len = str.Length;
int i = 0;

while(i <len)
{
    while(i < len && str[i] == ' ')
    {
        i++;
    }

    if (i < len)
    {
        int nextSpaceIdx = findSpaceIdx(str, i);
        Rotate(str, i, nextSpaceIdx - 1);

        i = nextSpaceIdx;
    }               
}

private int findSpaceIdx(char[] str, int startIdx)
{
    int idx = startIdx;
    while(idx < str.Length)
    {
        if (str[idx] == ' ')
        {
            break;
        }
        idx++;
    }

    // idx can be space idx or len+1
    return idx;
}


/// <summary>
/// 680
/// https://leetcode.com/problems/valid-palindrome-ii/description/
/// Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.
///Example 1:
///Input: "aba"
///Output: True
///Example 2:
///Input: "abca"
///Output: True
///Explanation: You could delete the character 'c'.
///Note:
///The string will only contain lowercase characters a-z.The maximum length of the string is 50000.
///
/// Sol:
/// 
/// check if curr string can be palindrome.
/// if not, remove left char || remove right char and see

[code]
if (!hasMismatch)
{
    return true;
}
else
{
    return simpleValidPalindrome(s.Substring(left, (right - left)))
        || simpleValidPalindrome(s.Substring(left + 1, (right - left)));



/// <summary>
/// https://www.lintcode.com/problem/implement-strstr/description
/// 13. Implement strStr()
/// For a given source string and a target string, you should output the first index(from 0) of target string in source string.
/// 
/// If target does not exist in source, just return -1.
/// 
/// Example
/// If source = "source" and target = "target", return -1.
/// 
/// If source = "abcdabcdefg" and target = "bcd", return 1.
///  
     Sol: corner condition like source or target is null

O(n^2)

for(int i=0; i <= (lenSource-lenTarget); i++)
{
    if (containsTarget(source, target, i, lenTarget))
    {
        return i;
    }
}

(O(M+N))

Sol: use hash  and walk through source until find the same len of the target and compare with target hash
(1)first to find target (smaller string) hash
foreach (char c in target)
{
    targetHash = (targetHash * 31 + c) % HashSlots;
}

(2) 
if i > target.length, we need to substract (-) the highest bit by follow hash and prepare to new lower bit to add to hash
get higest bit
for(int i = 1; i <=targetLen; i++)
{
    hash = (hash * 31) % HashSlots;
}


// curr len is > target, need to remove high bit
for (int i = 0; i < slen; i++)
{
    // (a*31*31 + b*31 + c)  % 5
    sourceSubStrHash = (sourceSubStrHash * 31 + source[i]) % HashSlots;

    // now we have full length of target, check if first match. 
    if (i==(target.Length-1) && sourceSubStrHash == targetHash)
    {
        return i - target.Length + 1;
    }
    // abc  + d,  remove the highest hash so we can add a newer low bit to hash (keep the same lenght as target) 
    if (i >= target.Length)
    {

        // substract the highest bit number
        //sourceSubStrHash -= ((source[i-targetlen] * 31 ^ (target.Length))%HashSlots);    // might overflow

        sourceSubStrHash -= ((source[i-target.Length] * highestpower)%HashSlots);

        if (sourceSubStrHash < 0)
        {
            sourceSubStrHash += HashSlots;
        }

        if (sourceSubStrHash == targetHash)
        {
            // need to double confirm with reach char compare, to prevent hash collision
            if (source.Substring(i-target.Length+1, target.Length).Equals(target) )
            {
                return i - target.Length + 1;
            }                
        }

    }
}



//235
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
// O(sqrt(N))
[CODE]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime
{
    while (num%i ==0)
    {
        ans.Add(i);
        num /= i;
    }
}

if (num > 1)
{
    ans.Add(num);
}



/// 50. Pow(x, n)
/// https://leetcode.com/problems/powx-n/description/
/// Implement pow(x, n), which calculates x raised to the power n (xn).
else if (n < 0)
{
    // yic
    //max 2147483647
    //min -2147483648
    if (n == Int32.MinValue)     
    {
        return MyPow(Math.Abs(1 / x), Int32.MaxValue);  // -2147483648  -> 2147483647   if - value, the final is positive
    }
    return MyPow(1 / x, -n);
}  

private double powerHelper(double x, int n)
{
    if (n == 1)
    {
        return x;
    }
    double half = powerHelper(x, n / 2);

    if (n%2 == 0)
    {
        return half * half;
    }

    return half * half * x;

}       


/// lint 140 fast power
///  https://www.lintcode.com/problem/fast-power/description
///  Calculate the a^n % b where a, b and n are all 32bit integers.
///  For 2^31 % 3 = 2
[code]
hanle a=0  n = 0 case.
Then

long product = fastPowerSolver(a, b, n / 2);
product = (product * product) %b;
if (n%2 == 0)
{
    return (int)product;
}
return (int)((product * a) %b);


/// 585. Maximum Number in Mountain Sequence
/// https://www.lintcode.com/en/old/problem/maximum-number-in-mountain-sequence/
/// 
/// Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.
/// Example
/// Given nums = [1, 2, 4, 8, 6, 3] return 8
/// Given nums = [10, 9, 8, 7], return 10 
[code]
while((left + 1) < right)
{
    // must be at least 3 elem to check
    int mid = left + (right - left) / 2;

    if (nums[mid-1] < nums[mid] && nums[mid] > nums[mid+1])     // yic  check mid-1  mid mid+1   not left, right
    {
        return nums[mid];
    }
    else if (nums[mid-1] <= nums[mid])
    {
        left = mid;
    }
    else
    {
        right = mid;
    }
}
// when out, it must be on the left/right edge
return Math.Max(nums[left], nums[right]);



/// 153
/// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e.,  [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
case     4 5 6 [0] "1" 2 3
case     4 5 6 [7] 8 9 "2"

/// Find the minimum element.
/// use binary search, and use "midV vs arr[right]""
///   smaller => go left to  get smallest,  bigger => go right
[code]
while((left +1) < right)
{
    int mid = left + (right - left) / 2;

    // yic  find smallest, check  mid and right
    // mid < right  (ascending),  go left to fiind min
    if (nums[mid] <= nums[right])
    {
        right = mid;
    }
    else
    {
        // 3 [4] 5 2
        left = mid;
    }
}

return nums[left] < nums[right] ? nums[left] : nums[right];



/// <summary>
/// 33. Search in Rotated Sorted Array
/// https://leetcode.com/problems/search-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e., [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
/// You are given a target value to search.If found in the array return its index, otherwise return -1.
/// 
/// You may assume no duplicate exists in the array.
case     4 5 6 [0] 1 2 3
case     4 5 6 [7] 8 9 2
[code]
while(left +1 < right)
{
    int mid = left + (right - left)/2;
    if (nums[mid] == target)
    {
        return mid;
    }
    // ascendint region
    if (nums[mid] < nums[right])
    {
        if (nums[mid] <= target && target <= nums[right])
        {
            left = mid;
        }
        else
        {
            right = mid;
        }
    }
    else
    {
        //3 4 [5] 6 1
        if (nums[left] <= target && target <= nums[mid])
        {
            right = mid;
        }
            else
        {
            left = mid;
        }
    }

}

if (nums[left] == target)
{
    return left;
}
else if (nums[right] == target)
{
    return right;
}
return -1;


/// 215. Kth Largest Element in an Array
/// https://leetcode.com/problems/kth-largest-element-in-an-array/description/
/// Find the kth largest element in an unsorted array. Note that it is the 
/// kth largest element in the sorted order, not the kth distinct element.
/// 
/// Example 1:
/// 
/// Input: [3,2,1,5,6,4]
///         and k = 2
/// Output: 5
/// Example 2:

[code]   k is the kIndex (0 based) not kth

int left = start;
int right = end;

int pivot = nums[start + (end - start) / 2];

while(left <= right)
{
    while(left <= right && nums[left] > pivot)
    {
        left++;
    }
    while (left <= right && nums[right] < pivot)
    {
        right--;
    }

    if (left <= right)
    {
        swap(nums, left++, right--);
    }
}

if (start <= k && k <= right)
{
    return SelectionSort(nums, k, start, right);
}
else if (left <= k && k<=end)
{
    return SelectionSort(nums, k, left, end);
}
else
{
    return nums[(left + right) / 2];
}



/// <summary>
/// 228. Middle of Linked List

/// https://www.lintcode.com/problem/middle-of-linked-list/description
/// Given 1->2->3, return the node with value 2.
/// Given 1->2, return the node with value 1.
[code]  fast.next.next != null to prevent move on for odd case
 
while (fast!=null && fast.next !=null && fast.next.next!=null)
{
    slow = slow.next;
    fast = fast.next.next;
}


/// lint 57. 3Sum
///https://www.lintcode.com/problem/3sum/description
///Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in 
///the array which gives the sum of zero.
///Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
///The solution set must not contain duplicate triplets.
///
/// For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:
/// (-1, 0, 1)
/// (-1, -1, 2)     
/// 
/// sol:
/// 
/// cannot use hashset as it does not rember the index and if it has appear before,
/// so use 2 pointers,  if first number exist, go right
///  if second number (after add to answer) exists before, go right

[code]
 // sort for the ans requirement (list to be ascending)
for (int i = 0; i < len; i++)
{
    // skip duplicate
    if (i != 0 && pre == nums[i])
    {
        continue;
    }

    int target = -1 * nums[i];
    int start = i + 1;
    int last = len - 1;

    int left = start;
    int right = last;
    while (left < right)
    {
        if (left != start && nums[left] == nums[left-1])
        {
            left++;
            continue;
        }

        if (nums[left] + nums[right] == target)
        {
            ans.Add(new List<int>() { nums[i], nums[left], nums[right] });
            left++;
        }
        else if ((nums[left] + nums[right]) > target)
        {
            right--;
        }
        else
        {
            left++;
        }
    }

    pre = nums[i];
}




 609. Two Sum - Less than or equal to target
/// https://www.lintcode.com/en/old/problem/two-sum-less-than-or-equal-to-target/
/// Given an array of integers, find how many pairs in the array such that their sum is less than or equal to a specific target number.
/// Please return the number of pairs.
/// Have you met this question in a real interview?
/// Example
/// Given nums = [2, 7, 11, 15], target = 24.
/// Return 5. 
//  2 + 7 < 24
//  2 + 11 < 24
//  2 + 15 < 24
//  7 + 11 < 24
//  7 + 15 < 25

/// sol:
/// 
///  use 2 pointers
/// 
///      [i]    j
///      
//   start from   i = j-1, and find the first index that (nums[j]+nums[i]) <=target
///  at lease 0~i should also be able to count as valid (because is even lower after sort)
[code]

Array.Sort(nums);   // sort from small to large
while (left < right)
{
    if (nums[left] + nums[right] <= target)
    {
        ans += (right - left);   // yic  means, [left ...-> (right    will be smaller as well   ex.  [3]  4 5  6 [7]   target 3+7=  10,  means [3]+6  [3]+5 will be smaller, and 
                                    //  next step we move left [3], so won't have duplicate  
        left++;
    }
    else
    {
        right--;
    }
}

 /// <summary>
/// 443. Two Sum - Greater than target
/// https://www.lintcode.com/problem/two-sum-greater-than-target/description
/// Given an array of integers, find how many pairs in the array such that their sum is bigger than a specific target number. 
/// Please return the number of pairs.
///Example
///Given numbers = [2, 7, 11, 15], target = 24. Return 1. (11 + 15 is the only pair)
[code]
while(left < right)
{
    if (nums[left] + nums[right] > target)
    {
        ans += (right - left);    // yic means [left  .... + (right will be also greater   ex.  3  4 5  6 [7]   target  3+[7] =10  
                                    //means 4+[7]  5+[7] will be greater as well,  next step we move left [7], so won't have duplicate  
        right--;
    }
    else
    {
        left++;
    }              
}


/// 200. Number of Islands
/// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed 
/// by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
[code]

 for (int j = 0; j < m; j++)
{
    for (int i = 0; i < n; i++)
    {
        if (grid[j, i] == '1' && visited[j, i] == false)
        {
            // go to BFS and mark visited
            BFSHelper(grid, visited, m, n, i, j);
            numOFIsland++;
        }
    }
}

 private void BFSHelper(char[,] grid, bool[,] visited, int m, int n, int i, int j)
{
    Queue<Location> stk = new Queue<Location>();
    stk.Enqueue(new Location(i, j));

    visited[j, i] = true;
    // need to look for 4 dirs, because we rely on all must be visited in a BFS helper,  each push can be from all dirs
    List<Location> deltas = new List<Location>() { new Location(1, 0), new Location(-1, 0), new Location(0, 1), new Location(0, -1) };

    while (stk.Count > 0)
    {
        var loc = stk.Dequeue();

        foreach (var delta in deltas)
        {
            int nx = loc.x + delta.x;
            int ny = loc.y + delta.y;
            if ((nx >= 0 && nx < n) && (ny >= 0 && ny < m) && grid[ny, nx] == '1' && visited[ny, nx] == false)  // not yet visited land
            {
                visited[ny, nx] = true;
                stk.Enqueue(new Location(nx, ny));
            }
        }
    }
}


/// 207. Course Schedule
/// https://leetcode.com/problems/course-schedule/description/
/// There are a total of n courses you have to take, labeled from 0 to n-1.

/// Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
/// 
/// Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
/// Example:
/// 
/// Input: 2, [[1,0],[0,1]]
/// Output: false
sol:
// (1) compute the inbound count and build child graph (so that we can traverse to next child)
Dictionary<int, int> inLookup = new Dictionary<int, int>();   // node , inbound count
Dictionary<int, List<int>> childLookup = new Dictionary<int, List<int>>();   // parent-> children
// (2) put no inbound to queue
 for (int i = 0; i < numCourses; i++)
{
    if (!inbound.ContainsKey(i))
    {
        ans.Add(i);
        queue.Enqueue(i);
    }
}

// (3) traverse to next course, --child inbound, 0 then put to queue, finish when queue empty
    int finishCount = 0;
    while (queue.Count > 0)
    {
        int curr = queue.Dequeue();  // 0  root
        finishCount++;
        if (childLookup.ContainsKey(curr))   // yic  prevent the last node  no child exception
        {
            var ListNextCourses = childLookup[curr];
            foreach (int nxt in ListNextCourses)
            {
                inLookup[nxt]--;

                // new root node found
                if (inLookup[nxt] == 0)
                {
                    queue.Enqueue(nxt);  // only no pre can insert to queue
                }
            }
        }
    }

    return finishCount == numCourses;



/// lint 611 Knight Shortest Path
/// https://www.lintcode.com/problem/knight-shortest-path/description
/// Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.
/// Return -1 if knight can not reached.
/// 
/// If the knight is at (x, y), he can get to the following positions in one step:
/// (x + 1, y + 2)
/// (x + 1, y - 2)
/// (x - 1, y + 2)
/// (x - 1, y - 2)
/// (x + 2, y + 1)
/// (x + 2, y - 1)
/// (x - 2, y + 1)
/// (x - 2, y - 1)
//Sol :use BFS level order to get min steps count
[code]
step = 0;
while(queue.Count > 0)
{
    int levelSize = queue.Count;

    for (int i = 0; i <levelSize; i++)
    {
        var curr = queue.Dequeue();

        if (curr.x == destination.x && curr.y == destination.y)
        {
            return steps;    // yic check  source == destination
        }

        // look for 8 surrandings 
        foreach (var deltaP in deltas)
        {
            var newPoint = new Point(curr.x + deltaP.x, curr.y + deltaP.y);

            if (newPoint.x >= 0 && newPoint.x < xLen && newPoint.y >= 0 && newPoint.y < yLen
                && grid[newPoint.x, newPoint.y] == false   // no block
                && visited[newPoint.x, newPoint.y] == false)
            {
                visited[newPoint.x, newPoint.y] = true;   //yic  true first
                queue.Enqueue(newPoint);
            }
        }

    }

    steps++;  // yic, step ++ here   ex, source==dest
}


/// 444. Sequence Reconstruction
/// https://leetcode.com/problems/sequence-reconstruction/description/
/// Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a 
/// permutation of the integers from 1 to n, with 1 ≤ n ≤ 10^4. Reconstruction means building a shortest common supersequence 
/// of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). 
/// Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.
/// Example 1:
/// 
/// Input:
/// org: [1,2,3], seqs: [[1,2,3],[1,3]]
sol:
 use topological sort. None anyone seq can bigger than count 2.
 if unique. 
 // early terminate when more than 1 choices
 while(queue.Count == 1)

 if (org.Length == tSortArr.Count && inbound.Keys.Count == org.Length)   //yic make sure inbound all node are calculated





/// 133 Clone Graph
/// https://leetcode.com/problems/clone-graph/description/
/// 
/// Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
/// 
/// Nodes are labeled uniquely.
/// 
/// We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
/// As an example, consider the serialized graph {
///             0,1,2#1,2#2,2}.
/// 
/// The graph has a total of three nodes, and therefore contains three parts as separated by #.
/// 
/// First node is labeled as 0.Connect node 0 to both nodes 1 and 2.
/// Second node is labeled as 1.Connect node 1 to node 2.
/// Third node is labeled as 2.Connect node 2 to node 2(itself), thus forming a self-cycle.
/// Sol:
///  first copy node by bfs to dictionary<orig, new>
/// for each dic keys, find orig neighbors and assign coped neighbor to new node 
[code]
Queue<UndirectedGraphNode> queue = new Queue<UndirectedGraphNode>();
Dictionary<UndirectedGraphNode, UndirectedGraphNode> lookup = new Dictionary<UndirectedGraphNode, UndirectedGraphNode>();  // old, new
queue.Enqueue(node);
lookup.Add(node, new UndirectedGraphNode(node.label));


 // link new neighbors by old neighbors
foreach(UndirectedGraphNode n in lookup.Keys)
{
    var copiedNode = lookup[n];
    foreach(var neighbor in n.neighbors)
    {
        copiedNode.neighbors.Add(lookup[neighbor]);
    }
}


 /// 624. Remove Substrings
/// https://www.lintcode.com/problem/remove-substrings/description
/// Given a string s and a set of n substrings.You are supposed to remove every instance of those n substrings 
/// from s so that s is of the minimum length and output this minimum length.
/// 
/// Example
/// Given s = ccdaabcdbb, substrs = ["ab", "cd"]
/// Return 2

[code]
if (visited.Contains(s))
{
    return;
}

minLen = Math.Min(s.Length, minLen);

foreach(string word in dict)
{
    if (s.Contains(word))
    {
        HashSet<string> shorterStrs = RemoveSubstr(s, word);
        foreach(string shorterStr in shorterStrs)
        {
            MinLengthHelper(shorterStr, dict);
        }
                                      
    }
}

visited.Add(s);




 /// 261 Graph Valid Tree
/// https://leetcode.com/problems/graph-valid-tree/description/
/// Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
/// 
///         For example:
/// 
/// Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.
/// 
/// Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
/// 
/// Note: you can assume that no duplicate edges will appear in edges.Since all edges are undirected, [0, 1] is the same as [1, 0]
///         and thus will not appear together in edges.
///         
/// Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path.”
/// 
/// 
/// Sol:
///  UnionFind when add a node their parent should not be the same initially,          
/// in case 2 , when [1,3] is added, found that 1  and 3 point to the same parent, which should not be the case for real tree
[code]
UnionFindGraphValidTree uf = new UnionFindGraphValidTree(n); // n nodes

for (int i = 0; i< numEdges; i++)
{
    int n1 = edges[i, 0];
    int n2 = edges[i, 1];

    int rootA = uf.Find(n1);
    int rootB = uf.Find(n2);

    if (rootA == rootB)
    {
        return false;
    }

    uf.Union(n1, n2);
}

return (uf.Count==1);   // yic for disjoin graph


 public int Find(int a)
{
    if (a != ufArray[a])
    {
        int topAncestor = Find(ufArray[a]);
        ufArray[a] = topAncestor;
    }
    return ufArray[a];
}



/// 431. Connected Component in Undirected Graph
/// https://www.lintcode.com/problem/connected-component-in-undirected-graph/description
/// Find the number connected component in the undirected graph. Each node in the graph contains a label and a list of its neighbors. (a connected component (or just component) of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.)
/// 
/// Example
/// Given graph:
/// 
/// A------B  C
///  \     |  | 
///   \    |  |
///    \   |  |
///     \  |  |
///       D   E
/// Return {A,B,D}, {C,E}. Since there are two connected component which is {A,B,D}, {C,E}

sol:  use HashSet<int> to find how many distinct nodes, then use UnionFind, since nodes are A, B, C  not 0 1 2 ..
need to use HashMap<char, char>  for node, parent in union



/// 110. Balanced Binary Tree
/// https://leetcode.com/problems/balanced-binary-tree/description/
/// Given a binary tree, determine if it is height-balanced.
[code]
if (root == null)
{
    return 0;
}

int leftPath = longestPath(root.left);
int rightPath = longestPath(root.right);

if (Math.Abs(leftPath - rightPath) > 1)
{
    isBalanceFalg = false;
}

return Math.Max(1+leftPath, 1+rightPath);



573. Build Post Office II
/// https://www.lintcode.com/problem/build-post-office-ii/description
/// Given a 2D grid, each cell is either a wall 2, an house 1 or empty 0 (the number zero, one, two), find a place to build a post office so that the 
/// sum of the distance from the post office to all the houses is smallest.
/// 
/// Return the smallest sum of distance.Return -1 if it is not possible.
Sol:
 /// BFS in each 0 location and compute the sum, find the min sum, Note: look for 4 directions
[code]
while(queue.Count > 0)
{
    int levelSize = queue.Count();

    for (int k = 0; k < levelSize; k++)
    {
        Location curr = queue.Dequeue();  // should be 0   empty
        foreach (var delta in deltas)
        {
            int nI = curr.i + delta.i;
            int nJ = curr.j + delta.j;

            if (nI < totalI && nI >= 0 && nJ < totalJ && nJ >= 0 && !visited[nI, nJ])  // yic  visited  is needed
            {
                if (grid[nI, nJ] == 0)    // empty, can walk to next position
                {
                    queue.Enqueue(new Location(nI, nJ));
                }
                else if (grid[nI, nJ] == 1)  // house
                {
                    sum += (step + 1);
                    numHouse--;
                }
                visited[nI, nJ] = true;
            }  
        }
    }
    step++;
}



// Binary Search Tree Removal
http://www.algolist.net/Data_structures/Binary_search_tree/Removal



/// <summary>
/// 79 
/// Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). 
/// If nums = [1,2,2], a solution is: 
///           [
///             [2],
///             [1],
///             [1,2,2],
///             [2,2],
///             [1,2],
///             []
///           ]
[code]
if (index >= nums.Length)
{
    List<int> copy = new List<int>(currPath);
    ans.Add(copy);
    return;
}

// add 
currPath.Add(nums[index]);
dfsHelper2(nums, index + 1, currPath, ans);
currPath.RemoveAt(currPath.Count -1);

// no add
int i = index + 1;
while (i < nums.Length && nums[i] == nums[i-1])
{
    i++;
}

dfsHelper2(nums, i, currPath, ans);



//235
//Prime Factorization
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
// O(sqrt(N))
// sol  for from 2 to sqrt(N)  + the leftover num   ( sqrt 34 is 5.   34/2 = 17)
[code]
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime
{
    while (num%i ==0)
    {
        ans.Add(i);
        num /= i;
    }
}

if (num > 1)
{
    ans.Add(num);
}



/// 140
/// Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words. 
///         Return all such possible sentences.
///         For example, given
/// s = "catsanddog",
/// dict = ["cat", "cats", "and", "sand", "dog"]. 
/// A solution is ["cats and dog", "cat sand dog"].
/// Sol:  don't forget memoizaiton

// think each return I want List<subString>,  be carefore for the whole word match case
[code]

private List<string> DFSHelper2(string s, int index, IList<string> wordDict, Dictionary<int, List<string>> visited)
{
    if (visited.ContainsKey(index))
    {
        return visited[index];
    }

    List<string> currAns = new List<string>();

    for (int i = index; i <s.Length; i++)
    {
        string substr = s.Substring(index, i - index + 1);
        if (wordDict.Contains(substr))
        {
            // reached last word
            if (i+1 >= s.Length)
            {
                currAns.Add(substr);
            }
            else
            {
                // not last word
                List<string> suffixStrs = DFSHelper2(s, i + 1, wordDict, visited);

                foreach (var suffix in suffixStrs)
                {
                    // only add to ans if suffix has something
                    currAns.Add(substr + " " + suffix);
                }
            }
                    
        }
    }

    visited.Add(index, currAns);

    return currAns;

}


/// https://leetcode.com/problems/wildcard-matching/description/
/// 
/// '?' Matches any single character.
/// '*' Matches any sequence of characters(including the empty sequence).
/// 
/// The matching should cover the entire input string (not partial).
// sol recursive,  be aware case   like   s:""  pattern: "**"   
[code]
private bool IsMatchHelper2(string s, string p, bool[,] visited,  bool[,] memo, int i, int j)
{
    int sLen = s.Length;
    int pLen = p.Length;
    if (i == sLen && j == pLen)  // both ran out
    {
        return true;
    }

    if (j == p.Length)   // yic: only pattern ran out
    {
        return false;
    }
    if (i == s.Length)  // yic s ran out
    {
        if (p[j] == '*')
        {
            return IsMatchHelper2(s, p, visited, memo, i, j + 1);  // match 0 case
        }
        return false;
    }

    if (visited[i,j])
    {
        return memo[i, j];
    }

    bool canMatch = false;

    if (s[i] == p[j])
    {
        canMatch = IsMatchHelper2(s, p, visited, memo, i + 1, j + 1);
    }
    else if (p[j] == '?')
    {
        canMatch = IsMatchHelper2(s, p, visited, memo, i + 1, j + 1);
    }
    else if (p[j] == '*')
    {
        canMatch = IsMatchHelper2(s, p, visited, memo, i, j + 1)   // match 0
                || IsMatchHelper2(s, p, visited, memo, i+1, j + 1)   // match 1
                || IsMatchHelper2(s, p, visited, memo, i+1, j);  // match many
    }
    else
    {
        //s[i]!=p[j]
        canMatch = false;
    }
    visited[i, j] = true;
    memo[i, j] = canMatch;

    return canMatch;
}


/// 10
/// https://leetcode.com/problems/regular-expression-matching/description/
/// '.' Matches any single character.
/// '*' Matches zero or more of the preceding element.
/// 
/// The matching should cover the entire input string (not partial).
private bool IsMatchHelper(string s, string p, bool [,] F, bool[,] visited, int i, int j)
{
    if (i < 0 & j < 0)
    {
        return true;
    }
    if (i < 0)
    {
        if (p[j] == '*')
        {
            return IsMatchHelper(s, p, F, visited, i, j-2);  // assume th patern is valid,   s""  p "a*"
        }
        else
        {
            return false;
        }
    }
    else if (j < 0)   // i != 0  & j==0
    {
        return false;
    }   

    if (visited[i,j])
    {
        return F[i, j];
    }

    if (s[i] == p[j])
    {
        F[i, j] = IsMatchHelper(s, p, F, visited, i - 1, j - 1);
    }
    else if (p[j] == '.')   // match any single char
    {
        F[i, j] = IsMatchHelper(s, p, F, visited, i - 1, j - 1);
    }
    else if (p[j] == '*')
    {
        bool match0 = IsMatchHelper(s, p, F, visited, i, j - 2);   // match 0 case
        bool match1 = false;
        bool match2 = false;

        if (p[j-1] == s[i] || p[j-1] == '.')   // yic: remember char need to match before going down
        {
            match1 = IsMatchHelper(s, p, F, visited, i - 1, j - 2); // match 1 case    abc   <-- ab.*  | abc*
            match2 = IsMatchHelper(s, p, F, visited, i - 1, j);   // match multi case
        }
                

        F[i, j] = match0 || match1 || match2;
    }
    else
    {
        F[i, j] = false;
    }

    visited[i, j] = true;

    return F[i, j];
}



/// 46
///https://leetcode.com/problems/permutations/description/
///Given a collection of distinct integers, return all possible permutations.
///
/// sol: DFS  can easily handle duplicate number
[code]
// visited  is for each unique location, don't insert again to currPath
private static void DFSHelper(int[] nums, List<int> currPath, List<List<int>> ans, bool[] visited)
{
    if (currPath.Count == nums.Length)
    {
        List<int> copy = new List<int>(currPath);
        ans.Add(copy);
        return;
    }
    HashSet<int> currLevelHasVisitedValue = new HashSet<int>();

    for (int i = 0; i < nums.Length; i++)
    {
        if (visited[i])
        {
            continue;
        }

        if (currLevelHasVisitedValue.Contains(nums[i]))
        {
            continue;
        }

        currLevelHasVisitedValue.Add(nums[i]);

        visited[i] = true;
        currPath.Add(nums[i]);

        DFSHelper(nums, currPath, ans, visited);

        currPath.RemoveAt(currPath.Count - 1);
        visited[i] = false;
    }
}


/// 10. String Permutation II
/// https://www.lintcode.com/problem/string-permutation-ii/description
/// Given a string, find all permutations of it without duplicates.
/// 
/// Example
/// Given "abb", return ["abb", "bab", "bba"].
/// 
/// Given "aabb", return ["aabb", "abab", "baba", "bbaa", "abba", "baab"].
/// sol:   use dfs to handle duplicate 
if (sb.Length == str.Length)
{
    ans.Add(sb.ToString());
    return;
}

// to prevent duplicate
HashSet<char> currVisited = new HashSet<char>();

for (int i = 0; i < str.Length; i++)
{
    if (visited[i] || currVisited.Contains(str[i]))
    {
        continue;
    }

    currVisited.Add(str[i]);

    visited[i]= true;
    sb.Append(str[i]);

    DFSHelper(str, sb, ans, visited);

    sb.Remove(sb.Length - 1, 1);
    visited[i] = false;
}

/// 51. N-Queens
/// https://leetcode.com/problems/n-queens/description/
/// The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
/// Given an integer n, return all distinct solutions to the n-queens puzzle.
/// Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.
/// Input: 4
/// Output: [
///          [".Q..",  // Solution 1
///           "...Q",
///           "Q...",
///           "..Q."],
/// 
///  ["..Q.",  // Solution 2
///   "Q...",
///   "...Q",
///   ".Q.."]
///  ]

// sol  canot be in the same col, and diag
/// [diagnal case 1]
/// (1,2)
///     (x,y)
///         (3,4)
/// 
/// column - row == const
/// 
/// [diagnal case 2]
///                (1,4)
///           (x, y)
///      (3,2)
///      
/// column + row = const
private void DFSHelper(int n, List<int> queenLocs, int currRow, List<List<string>> ans)



//681. Next Closest Time
//https://leetcode.com/problems/next-closest-time/description/
/// <summary>
/// Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.

///You may assume the given input string is always valid.For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.
///
///Example 1:
///
///
///Input: "19:34"
///Output: "19:39"
///Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39
///
/// sol: DFS and use orign time char as candidate,  convert all to min and compare if new number diff is smaller
/// for negative  (23:59   -> 22:22) need to  +24*60 as diff
private void dfsHelper(HashSet<char> candidate, int index, string currpath)
{
    if (index == 4)
    {
        int candidateTimeMin = ConvertPureTimeStrToMinute(currpath);
        int currDiff = (candidateTimeMin - baseTimeMin) >= 0 ? 
            (candidateTimeMin - baseTimeMin) :
            (candidateTimeMin - baseTimeMin) + 24*60;   // next day

        // find a smaller candidate but not the same
        if (currDiff != 0 && mindiff > currDiff)
        {
            ans = currpath.Substring(0, 2) + ":" + currpath.Substring(2, 2);
            mindiff = currDiff;  // yic don't forget
        }
        return;
    }

    foreach (char c in candidate)
    {
        if (index == 0 && c > '2')
        {
            continue;
        }
        else if (index == 1 && (currpath[0]-'0')*10+c-'0' >23 )   // yic 0~23: has limit 
        {
            continue;
        }
        else if (index == 2 && c > '5') // 23:59
        {
            continue;
        }
        else if (index ==3 && (currpath[2]-'0')*10 + (c-'0') > 59)  // 0~59
        {
            continue;
        }

        dfsHelper(candidate, index + 1, currpath + c);
    }

}


// 291. Word Pattern II
/// https://leetcode.com/problems/word-pattern-ii/description/
/// 
/// Given a pattern and a string str, find if str follows the same pattern.
/// Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.
/// 
/// Example 1:
/// 
/// Input: pattern = "abab", str = "redblueredblue"
/// Output: true
/// Example 2:
/// 
/// Input: pattern = pattern = "aaaa", str = "asdasdasdasd"
/// Output: true
/// Example 3:
/// 
/// Input: pattern = "aabb", str = "xyzabcxzyabc"
/// Output: false
/// Notes:
/// You may assume both pattern and str contains only lowercase letters.
/// 这里遵循的意思是一个完整的匹配，在一个字母的模式和一个非空的单词str之间有一个双向连接的模式对应。
/// (如果a对应s，then b cannot match s。例如，给定的模式= "ab"， str = "ss"，返回false）。
[code]
 lookup = new Dictionary<char, string>();   // a -> "red"   b-> "blue"
used = new HashSet<string>();    // "red"   "blue"
var ans = DFSHelper(pattern, 0, str, 0);



/// wordsearch 2
 /// Given a 2D board and a list of words from the dictionary, find all words in the board.
///        Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring.The same letter cell may not be used more than once in a word.
///
///       For example,
///       Given words = ["oath", "pea", "eat", "rain"] and board =
///
///       [   
///         ['o','a','a','n'],
///         ['e','t','a','e'],
///         ['i','h','k','r'],
///         ['i','f','l','v']
///       ]
///Return["eat", "oath"].
//sol: build trie from words,  and at each DFS use Node to help determine if need to go to next level
[code]
if (visited[i,j])
{
    return;
}

visited[i, j] = true;

if (curr.hasWord)
{
    ans.Add(curr.word);
}

var deltasI = new int[] { 1, 0, -1, 0 };
var deltasJ = new int[] { 0, 1, 0, -1 };

for(int k = 0; k < 4; k++)
{
    int nI = i + deltasI[k];
    int nJ = j + deltasJ[k];
    if (!(nI < 0 || nI >= M || nJ < 0 || nJ >= N))
    {
        char nextC = board[nI, nJ];
        if (curr.children[nextC-'a'] != null)
        {
            FindWordsHelper(board, nI, nJ, M, N, curr.children[nextC - 'a'], visited, ans);
        }
    }          
}

visited[i, j] = false;




/// 387. First Unique Character in a String
/// https://leetcode.com/problems/first-unique-character-in-a-string/description/
/// Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.
/// 
/// Examples:
/// 
/// s = "leetcode"
/// return 0.
/// 
/// s = "loveleetcode",
/// return 2.
/// 
/// 
/// Sol:
/// 
/// for long data stream, use LRU cache
DummyHead(-1)   ---  DummyTail(-1)

HashMap[char, node]    if repeat  remove the node only.

The answer will be DummyHead.next.val    



/// https://www.lintcode.com/problem/insert-delete-getrandom-o1/description
/// 380. Insert Delete GetRandom O(1)
/// Design a data structure that supports all following operations in average O(1) time.
///insert(val): Inserts an item val to the set if not already present.
///remove(val): Removes an item val from the set if present.
///getRandom: Returns a random element from current set of elements.Each element must have the same probability of being returned.

Sol : use List<int>  for insert, 
use Dictionary<int,int>  as (val, index)  to quick lookup. For delete, swap value_index with the lasst item, then delete the last one.

Dictionary<int, int> lookup; // (val, index)
List<int> arr;
Random rd; 

 // (2-2) swap last item with removed one
int last = arr[arr.Count - 1];
arr.RemoveAt(arr.Count - 1);
arr[index] = last;
lookup[last] = index;  // update last new index loc


/// https://www.lintcode.com/problem/k-closest-points/description
/// lint 612. K Closest Points
/// Given some points and a point origin in two dimensional space, find k points out of the some points which are nearest to origin.
/// Return these points sorted by distance, if they are same with distance, sorted by x-axis, otherwise sorted by y-axis.
/// 
/// Example
/// Given points = [[4,6],[4,7],[4,4],[2,5],[1,1]], origin = [0, 0], k = 3
/// return [[1,1],[2,5],[4,4]]
Sol:

use Priority Queue ("max" heap) and pop when size > k,  in the end, only "smallest" k will be keep in the pq.

private Point global_origin = null;
    public Point[] kClosest(Point[] points, Point origin, int k) {
        // Write your code here
        global_origin = origin;
        PriorityQueue<Point> pq = new PriorityQueue<Point> (k, new Comparator<Point> () {
            @Override
            public int compare(Point a, Point b) {
                int diff = getDistance(b, global_origin) - getDistance(a, global_origin);
                if (diff == 0)
                    diff = b.x - a.x;
                if (diff == 0)
                    diff = b.y - a.y;
                return diff;
            }
        });

        for (int i = 0; i < points.length; i++) {
            pq.offer(points[i]);
            if (pq.size() > k)
                pq.poll();
        }
        
        k = pq.size();
        Point[] ret = new Point[k];  
        while (!pq.isEmpty())
            ret[--k] = pq.poll();
        return ret;
    }
    
    private int getDistance(Point a, Point b) {
        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
    }


/// Lint 398
/// http://www.lintcode.com/en/problem/longest-increasing-continuous-subsequence-ii/
/// 
/// Give you an integer matrix (with row size n, column size m)，find the longest increasing continuous subsequence in this matrix. 
/// (The definition of the longest increasing continuous subsequence here can start at any row or column and go up/down/right/left any direction).
/// 
///                {
///                  {1, 5,  3 },
///                  {4, 10, 9 },
///                  {2, 8,  7 }
///                };
/// 

Sol: DFS would timeout, use DP
if (visited[j,i] == true)
{
    return F[j, i];
}

// will not have loop be cause recursive only happen when neighber is smaller, wont come back to curr (j,i)
visited[j, i] = true;

int[] deltaXs = { -1, 1, 0, 0 };
int[] deltaYs = {  0, 0, 1,-1 };

F[j, i] = 1;  // init len is itself


for (int k = 0; k <4; k++)
{
    int nx = i + deltaXs[k];
    int ny = j + deltaYs[k];
    if (nx >= 0 && nx < N && ny >= 0 && ny < M && A[j, i] > A[ny, nx])
    {
        int preLen = LongestIncreasingContinuousSubsequenceIIHelper(A, F, visited, ny, nx, M, N);
        F[j, i] = Math.Max(F[j, i], (preLen + 1));
    }
}

            

return F[j, i];


/// 300
/// 
/// O(n^2 ) https://www.youtube.com/watch?v=CE2b_-XfVDk
/// O(nlongn)https://www.youtube.com/watch?v=S9oUiVYEq7E
/// 
/// Given an unsorted array of integers, find the length of longest increasing subsequence. 
///        For example,
///        Given[10, 9, 2, 5, 3, 7, 101, 18],
///        The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.
///Your algorithm should run in O(n2) complexity.
///
/// Sol
/// F[j] = max (1 self,    f[i]+1 if a[j] > a[i] 
public int LengthOfLIS(int[] nums)
{
    if (nums ==null || nums.Length ==0)
    {
        return 0;
    }

    int[] F = new int[nums.Length];
    for (int i = 0; i <nums.Length; i++)
    {
        F[i] = 1;
    }

    int ans = 1;

    for (int i =0; i < nums.Length; i++)
    {
        for (int j = 0; j < i; j++)
        {
            if (nums[j] < nums[i])
            {
                F[i] = Math.Max(F[i], F[j] + 1);
                ans = Math.Max(F[i], ans);
            }
                    
        }
    }
    return ans;
}


/// 53. Maximum Subarray
/// https://leetcode.com/problems/maximum-subarray/description/
/// Find the contiguous subarray within an array (containing at least one number) which has the largest sum. 
///        For example, given the array[-2, 1, -3, 4, -1, 2, 1, -5, 4],
///        the contiguous subarray[4, -1, 2, 1] has the largest sum = 6.
///          click to show more practice.
///          More practice: 
/// If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
///
/// sol:
/// 
currAccuSum - preAccuMin (<-  default to 0, and hope to get minus)

public int MaxSubArrayPractice(int[] nums)
{
    int currSum = 0;

    int ans = Int32.MinValue;
    int preAccuMin = 0;

    foreach(var num in nums)
    {
        currSum += num;

        int localMax =  Math.Max(currSum, currSum - preAccuMin);

        // yic don't forget
        ans = Math.Max(localMax, ans);


        preAccuMin = Math.Min(currSum, preAccuMin);

    }
    return ans;
}


/// 139. Subarray Sum Closest
/// https://www.jiuzhang.com/solution/subarray-sum-closest/
/// Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.
/// 
/// Example
/// Given[-3, 1, 1, -3, 5], return [0, 2], [1, 3], [1, 1], [2, 2] or[0, 4].

// sol:  sort sum  and flid neighbor items closet,  use 
Class Item
{
    public int sum;
    public int loc;

    public Item(int sum, int loc)
    {
        this.sum = sum;
        this.loc = loc;
    }
}

class ItemComparer : IComparer<Item>
{
    public int Compare(Item x, Item y)
    {
        return x.sum.CompareTo(y.sum);
    }
}

to help sort  but keep track of item location.




/// 57. Insert Interval
/// https://leetcode.com/problems/insert-interval/description/
/// Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
/// 
/// You may assume that the intervals were initially sorted according to their start times.
/// 
/// Example 1:
/// 
/// Input: intervals = [[1, 3], [6,9]], newInterval = [2,5]
/// Output: [[1,5],[6,9]]
sol:

add newInterval to intervals and sort by start.

then add item to Ans with the logic
[code]
Interval pre = intervals[0];
for (int i = 0; i < copy.Length; i++)
{
    if (i ==0)
    {
        ans.Add(copy[0]);
    }
    else
    {
        Interval curr = copy[i];
        if (pre.end < curr.start)   // okay to seperate
        {
            ans.Add(curr);
            pre = curr;
        }
        else  if (pre.end < curr.end)
        {
            pre.end = curr.end;   // override to longer interval end
        }
    }

}


/// 4. Median of Two Sorted Arrays
/// https://leetcode.com/problems/median-of-two-sorted-arrays/description/
/// https://github.com/mission-peace/interview/blob/master/src/com/interview/binarysearch/MedianOfTwoSortedArrayOfDifferentLength.java
/// 
/// There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays.
/// 
/// Example
/// Given A=[1,2,3,4,5,6]
/// and B =[2, 3, 4, 5], the median is 3.5.
/// 
/// Given A =[1, 2, 3] and B =[4, 5], the median is 3.
/// 
/// sol
/// 分治法。时间复杂度 log(n + m)
if ((len1 + len2) %2 == 0)
{
    int ans1 = FindKthFromSortedArrays(nums1, nums2, 0, 0, (len1 + len2) / 2 );
    int ans2 = FindKthFromSortedArrays(nums1, nums2, 0, 0, (len1 + len2) / 2 +1);
    return 1.0 * (ans1 + ans2) / 2;
}
else
{
    return FindKthFromSortedArrays(nums1, nums2, 0, 0, (len1 + len2) / 2+1);
}


private static int FindKthFromSortedArrays(int[] nums1, int[] nums2, int start1, int start2, int kth)
{
    //
    // 2 3
    // 4 5 6 7 8 9
    // can remove the longer one half since longer one must contrain waste
    if (start1 >= nums1.Length)
    {
        return nums2[start2+kth-1];     // yic "start"+kth -1
    }
    if (start2 >= nums2.Length)
    {
        return nums1[start1+kth-1];
    }

    // yic Important
    // 2 3
    // 1
    if (kth ==1)
    {
        return Math.Min(nums1[start1], nums2[start2]);
    }

    // 2 4 5 
    // 1 3 6    => half =  3

    int half = kth / 2;


    // cannot find half v from one of list
    if ((start1+half-1) >= nums1.Length)
    {
        //x 2 7
        //y 1 2 3 4
        return FindKthFromSortedArrays(nums1, nums2, start1, start2 + half, kth - half);
    }
    else if ((start2+half-1) >= nums2.Length)
    {
        return FindKthFromSortedArrays(nums1, nums2, start1 + half, start2, kth - half);
    }
    else
    {
        int num1HalfV = nums1[start1 + half - 1];
        int num2HalfV = nums2[start2 + half - 1];

        // redice size to half by rmove smaller half
        if (num1HalfV <= num2HalfV)
        {
            return FindKthFromSortedArrays(nums1, nums2, start1 + half, start2, kth - half);
        }
        return FindKthFromSortedArrays(nums1, nums2, start1, start2 + half, kth - half);
    }
}


/// 839. Merge Two Sorted Interval Lists
/// https://www.lintcode.com/problem/merge-two-sorted-interval-lists/description
/// Merge two sorted(ascending) lists of interval and return it as a new sorted list.The new sorted list should be made by splicing together the intervals of the two lists and sorted in ascending order.
/// 
///   Example
///   Given list1 = [(1, 2),(3,4)] and list2 = [(2, 3),(5,6)], return [(1, 4),(5, 6)].
List<Interval> ans = new List<Interval>();
SortedSet<Interval> pq = new SortedSet<Interval>(new IntervalComparer());

AddToPQ(pq, list1);
AddToPQ(pq, list2);

pop first to AnsList   <- pre
while (pq is not empty)
{
	pre , curr compare (add new interval or update tail)
}


/// 944. Maximum Submatrix
/// Given an n x n matrix of positive and negative integers, find the submatrix with the largest possible sum.
/// 
/// Example
/// Given matrix =
/// [
///     [1, 3, -1],
///     [2,3,-2],
///     [-1,-2,-3]
/// ]
/// return 9.
/// Explanation:
/// the submatrix with the largest possible sum is:
/// [
/// [1,2],
/// [2,3]
/// ]
/// 
/// 
/// Sol:
/// 枚举子矩阵的上下边界 up & down, 然后将这之间的数压缩为一个一维数组（降维攻击），剩下的任务就是一维数组如何求 Maximum Subarray 了。
/// 
/// set (up - down) range,  make it from 2d to 1d sum
/// then find max subarry sum


/// 311. Sparse Matrix Multiplication
/// https://leetcode.com/problems/sparse-matrix-multiplication/description/
///Given two Sparse Matrix A and B, return the result of AB.

4 * 3  X 3 * 2   =>  4*2
rA cA    rB  cB

/// time out  need to reorder  make A[j, i] in frist 2 for
//for (int k = 0; k < colB; k++)
//{
//    for (int j = 0; j < rowA; j++)
//    {
//        for (int i = 0; i < colA; i++)
//        {
//            ans[j, k] += A[j, i] * B[i, k];
//        }
//    }
//}

for (int i = 0; i < colA; i++)
{
    for (int j = 0; j < rowA; j++)
    {
        if (A[j, i] != 0)
        {
            for (int k = 0; k < colB; k++)
            {
                ans[j, k] += A[j, i] * B[i, k];
            }
        }

    }
}



/// leetcode 340
/// https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description
/// Given a string s, find the length of the longest substring T that contains at most k distinct characters.
/// 
/// Example
///        For example, Given s = "eceba", k = 3,
/// 
///        T is "eceb" which its length is 4. 

[code]

public int LengthOfLongestSubstringKDistinct(String s, int k)
{
    Dictionary<char, int> memo = new Dictionary<char, int>();

    int j = 0;
    int currLen = 0;
    int maxLen = 0;

    for (int i = 0; i < s.Length; i++)
    {
        while (j < s.Length && (memo.Keys.Count < k || (memo.Keys.Count==k && memo.ContainsKey(s[j]))))    // < count < k or count ==k  but old key
        {
            currLen++;

            if (!memo.ContainsKey(s[j]))
            {
                memo.Add(s[j], 0);
            }
            memo[s[j++]]++;
        }

        maxLen = Math.Max(maxLen, currLen);

        // now ready to move i
        memo[s[i]]--;
        if (memo[s[i]] == 0)
        {
            memo.Remove(s[i]);
        }
        currLen--;
    }

    return maxLen;
}


/// 465. Kth Smallest Sum In Two Sorted Arrays
/// http://www.lintcode.com/en/problem/kth-smallest-sum-in-two-sorted-arrays/
/// Given two integer arrays sorted in ascending order and an integer k. Define sum = a + b, 
/// where a is an element from the first array and b is an element from the second one. Find the kth smallest sum out of all possible sums.
/// 
/// 
/// Example
///  Given[1, 7, 11] and[2, 4, 6].
/// 
/// For k = 3, return 7.
/// 
/// For k = 4, return 9.
/// 
/// For k = 8, return 15
[sol]  use pq  and start with index (0,0)



SortedDictionary<int, List<Location>> pq = new SortedDictionary<int, List<Location>>(); // (sum, LocaitonS)

List<Location> initLocaitons = new List<Location>() { new Location(0, 0) }; //use List because: [1 3 5]   [2,4,6]   sum == 5 has (1,4), (2,5)
bool[,] visited = new bool[arrA.Length, arrB.Length];     
pq.Add(arrA[0] + arrB[0], initLocaitons);
visited[0, 0] = true;

List<Location> deltas = new List<Location>() { new Location(0, 1), new Location(1, 0) };    
            
int ans = 0;

for (int i = 0; i < k; i++)
{
    ans = pq.Keys.First();

    var locations = pq.Values.First();
    var location = locations[0];

    foreach(var delta in deltas)
    {
        int newLocX = location.x + delta.x;   // A index
        int newLocY = location.y + delta.y;   // B index

        if (newLocX < arrA.Length && newLocY < arrB.Length && visited[newLocX, newLocY] == false)     // YIC  boundary condition
        {
            visited[newLocX, newLocY] = true;
            var newSum = arrA[newLocX] + arrB[newLocY];
                        
            if (pq.ContainsKey(newSum))
            {
                pq[newSum].Add(new Location(newLocX, newLocY));
            }
            else
            {
                pq.Add(newSum, new List<Location>() { new Location(newLocX, newLocY) });
            }
        }
    }

    if (locations.Count == 1)
    {
        pq.Remove(ans);
    }
    else
    {
        locations.RemoveAt(0);  // remove first locaiton wth the same key
    }     
}


/// 609. Two Sum - Less than or equal to target
/// https://www.lintcode.com/en/old/problem/two-sum-less-than-or-equal-to-target/
/// Given an array of integers, find how many pairs in the array such that their sum is less than or equal to a specific target number.
/// Please return the number of pairs.
/// Have you met this question in a real interview?
/// Example
/// Given nums = [2, 7, 11, 15], target = 24.
/// Return 5. 
//  2 + 7 < 24
//  2 + 11 < 24
//  2 + 15 < 24
//  7 + 11 < 24
//  7 + 15 < 25

/// sol:
/// 
///  use 2 pointers
Array.Sort(nums);

int right = nums.Length - 1;
int left = 0;

while (left < right)
{
    if (nums[left] + nums[right] <= target)
    {
        ans += (right - left);   // yic  means, [left ...-> (right    will be smaller as well   ex.  [3]  4 5  6 [7]   target 3+7=  10,  means [3]+6  [3]+5 will be smaller, and 
                                    //  next step we move left [3], so won't have duplicate  
        left++;
    }
    else
    {
        right--;
    }

}

return ans;

/// 610. Two Sum - Difference equals to target
/// https://www.lintcode.com/problem/two-sum-difference-equals-to-target/description
/// Given an array of integers, find two numbers that their difference equals to a target value.
/// where index1 must be less than index2.Please note that your returned answers(both index1 and index2) are NOT zero-based.

Dictionary<int, int> lookup = new Dictionary<int, int>();

for (int i = 0; i < len; i++)
{
    // x - arr[i] == target

    if (lookup.ContainsKey(nums[i] + target))
    {
        int[] ans = new int[2];
        ans[0] = lookup[nums[i] + target];
        ans[1] = i;
        return ans;
    }

    // arr[i] -x == target
    if (lookup.ContainsKey(nums[i] - target))
    {
        int[] ans = new int[2];
        ans[0] = lookup[nums[i] - target];
        ans[1] = i;
        return ans;
    }

    lookup.Add(nums[i], i);

}

return null;


/// Lint 382. Triangle Count 
/// https://www.lintcode.com/en/old/problem/triangle-count/
/// Given an array of integers, how many three numbers can be found in the array, 
/// so that we can build an triangle whose three edges length is the three numbers that we find?
sol  Similiar to two sum bigger
[code]
Array.Sort(arr);
int ans = 0;
int len = arr.Length;

for (int i = len-1; i >=2; i--)
{
    // two sum greater
    int left = 0;
    int right = i - 1;

    while (left < right)
    {
        if (arr[left] + arr[right] > arr[i])
        {
            ans+=(right-left);
            right--;
        }
        else
        {
            left++;
        }
    }
}

return ans;



/// 76
/// Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 
/// For example,
/// S = "ADOBECODEBANC"
/// T = "ABC"
/// Minimum window is "BANC". 
sol:

   lookup dictionary for T, because T can be "BBB"\
   use score (ie tLen) to control innder while loop out condition
   for (i:0~len)
      while(j ~ len  && score > 0)

[Code]
// build lookup table
Dictionary<char, int> lookup = new Dictionary<char, int>();
foreach(char c in t)
{
    if (!lookup.ContainsKey(c))
    {
        lookup.Add(c, 0);
    }
    lookup[c]++;
}

// two pointer pattern
int score = tlen;
int j = 0;  // j always move forward

for (int i = 0; i < slen; i++)
{
    while(j < slen && score > 0)
    {
        if (lookup.ContainsKey(s[j]))
        {
            if (lookup[s[j]] >0)    // yic 
            {
                score--;
            }

            lookup[s[j]]--; 
        }

        j++;
    }

    if (score == 0)
    {
        int tempLen = (j-1) - i + 1;        // yic  Note:  j-1 because j++ before out of while loop
        if (ansLen > tempLen)
        {
            ans = s.Substring(i, tempLen);   // startidx, len
            ansLen = tempLen;           // yic
        }   
    }

    // i is about to move
    if (lookup.ContainsKey(s[i]))
    {
        lookup[s[i]]++;

        if (lookup[s[i]] > 0)    // yic 
        {
            score++;
        }
    }
}

return ans;



/// 721. Accounts Merge
/// https://leetcode.com/problems/accounts-merge/description/
/// Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.
/// 
/// Now, we would like to merge these accounts.Two accounts definitely belong to the same person if there is some email that is common to both accounts.Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.
/// 
/// 
/// After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.
/// 
/// 
/// Example 1:
/// Input: 
/// accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
/// Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
/// Explanation: 
/// The first and third John's are the same person as they have the common email "johnsmith@mail.com".
/// The second John and Mary are different people as none of their email addresses are used by other accounts.
/// We could return these lists in any order, for example the answer[['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],
/// ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.

/// sol:
/// 
/// (1) use UnionFind to get all emails connected components.
/// (2) also use Hashset to store emails, walk through each key and if they have the same parent, put into the same List, so each List will belong to the same person   Dicitonary(ParentMail, List(mails))
/// (3) for each person, get the first email and find its parent, and then find the corresponding list, note  need use hashset to cache visited ancestor mail since we want to skip the same user
public class UnionFindAccont
{
    Dictionary<string, string> unionLookup;

    public UnionFindAccont(HashSet<string> emails)
    {
        unionLookup = new Dictionary<string, string>();
        foreach (var email in emails)
        {
            unionLookup.Add(email, email);
        }
    }

    public string Find(string email)
    {
        if (email != unionLookup[email])
        {
            var ancestor = Find(unionLookup[email]);
            unionLookup[email] = ancestor;
        }
        return unionLookup[email];
    }

    public void Union(string email1, string email2)
    {
        // yic use find  
        string p1 = Find(email1);
        string p2 = Find(email2);

        if (p1 != p2)
        {
            //  yic use p2, not email
            unionLookup[p2] = p1;
        }
    }

}   


/// 42. Trapping Rain Water
/// https://leetcode.com/problems/trapping-rain-water/description/
/// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water 
/// it is able to trap after raining.
/// 
/// Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
/// 
/// sol:
/// 
/// use left and right,
/// 
// pick smaller height and got one direction to get area (since the otherside is higher, won't go over)  (stop when leftH <= arr[i])
// then reconsider choose left or right
while (left < right)
{
    int leftH = height[left];
    int rightH = height[right];

    if (leftH <= rightH)
    {
        int i = left + 1;
        while (leftH > height[i])
        {
            area += (leftH - height[i]);
            i++;
        }
        left = i;
    }
    else
    {
        int i = right - 1;
        while (height[i] < rightH)
        {
            area += (rightH - height[i]);
            i--;
        }
        right = i;
    }
}


/// 85
/// https://leetcode.com/problems/maximal-rectangle/description/
/// Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
/// 
/// For example, given the following matrix:
/// 1 0 1 0 0
/// 1 0 1 1 1
/// 1 1 1 1 1
/// 1 0 0 1 0
/// 
/// Return 6.     
[sol]  use find LargestRectangleInHistogram case,  keep accumulate to 1D array, (get 0 reset to 0)



/// 620. Maximum Subarray IV
/// https://www.lintcode.com/problem/maximum-subarray-iv/description
/// Given an integer arrays, find a contiguous subarray which has the largest sum, 
/// note length should be greater or equal to given length k.
/// Return the largest sum, return 0 if there are fewer than k elements in the array.
sol:  preMin = 0, aggregate num[i] tp sum, and queue sum, until queue.size ==k  than update preMin and comute ans


/// 523. Continuous Subarray Sum
/// https://leetcode.com/problems/continuous-subarray-sum/description/
/// iven a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.
/// 
/// Example 1:
/// Input: [23, 2, 4, 6, 7],  k=6
/// Output: True
/// Explanation: Because[2, 4] is a continuous subarray of size 2 and sums up to 6.

can do in O(n^2)   traditional 
for (int i = 0; i <len; i++)
{
    int sum = nums[i];
    for (int j = i+1; j <len; j++)
    {
        sum += nums[j];

        if (sum ==0 && k == 0)
        {
            return true;
        }
        else if (sum != 0 && k ==0)
        {
            continue;  // otherwise, will throw exception
        }
        else if (sum % k == 0)
        {
            return true;
        }
    }
}


or O(n)
sol:
/// 
///  use hashmap store % result, if repeat, means we find it
lookupResdule.Add(0, -1);

int sum = 0;

for (int i = 0; i < nums.Length; i++)
{
    sum += nums[i];

    if (k != 0)
    {
        sum = sum % k;
    }

    if (lookupResdule.ContainsKey(sum) && (i - lookupResdule[sum]) >= 2)
    {
        return true;
    }

    if (!lookupResdule.ContainsKey(sum))
    {
        lookupResdule.Add(sum, i);
    }
}


/// 162
/// Find Peak Element
/// https://leetcode.com/problems/find-peak-element/description/
/// A peak element is an element that is greater than its neighbors.
/// Given an input array where num[i] ≠ num[i + 1], find a peak element and return its index.
/// 
/// The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
/// 
/// You may imagine that num[-1] = num[n] = -∞.

[code]
int left = 0;
int right = N - 1;

while(left+1 < right)
{
    //at least 3 elemt
    int mid = (left + right) / 2;
    if (nums[mid] <= nums[mid + 1])
    {
        left = mid;
    }
    else
    {
        right = mid;
    }
}

if (nums[left] <= nums[right])
{
    return right;
}
return left;



/// 218
/// https://leetcode.com/problems/the-skyline-problem/description/
/// Given N buildings in a x-axis，each building is a rectangle and can be represented by a triple (start, end, height)，where start is the 
/// start position on x-axis, end is the end position on x-axis and height is the height of the building. Buildings may overlap if you see 
/// them from far away，find the outline of them。An outline can be represented by a triple, (start, end, height), where start is the start 
/// position on x - axis of the outline, end is the end position on x - axis and height is the height of the outline.
/// 
/// For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .
///The output is a list of "key points" (red dots in Figure B) in the format of[[x1, y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline.
///A key point is the left endpoint of a horizontal line segment.Note that the last key point, where the rightmost building ends, 
///is merely used to mark the termination of the skyline, and always has zero height.Also, the ground in between any two adjacent 
///buildings should be considered part of the skyline contour.

sweep line => (loc +H)  (loc -H) to maxheap  (loc, List<Height>)  

init ansHeap (Loc:0,H:0)
use  if (preHeight != currMaxHeight)  to prevent add loc with the smae height


// 182 Wood Cut
/// http://www.lintcode.com/en/problem/wood-cut/
/// Given n pieces of wood with length L[i] (integer array). Cut them into small pieces to guarantee you could 
/// have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? 
/// Given L & k, return the maximum length of the small pieces.

sol  use the larget segment as right, 1 as left

[code]
int maxWoodLen = FindMaxWoodLengthFromArray(L);

int left = 1;
int right = maxWoodLen;

while((left+1) < right)
{
    int mid = left + (right - left) / 2;
    int cuts = GetNumberOfCut(L, mid);

    if (cuts >= k)
    {
        left = mid;
    }
    else
    {
        right = mid;
    }
}

if (GetNumberOfCut(L, right)>=k)
{
    return right;
}
else if (GetNumberOfCut(L, left) >= k)
{
    return left;
}

return 0;



/// 161. One Edit Distance
/// https://leetcode.com/problems/one-edit-distance/description/
/// Given two strings S and T, determine if they are both one edit distance apart.

sol:
if (Math.Abs(M-N) > 1)

while (i >=0 && j >=0)
{
    if (s[i] == t[j])
    {
        i--;
        j--;
    }
    else
    {
        // delete case
        if (s.Substring(0, i) == t.Substring(0,j+1))   // yic note both s   i for len  current len-1, j+1 is totla len
        {
            return true;
        }
        // insert case
        else if ((s.Substring(0,i+1) + t[j]) == t.Substring(0, j + 1))
        {
            return true;
        }
        // replace case
        else if ((s.Substring(0,i) + t[j]) == t.Substring(0, j + 1))
        {
            return true;
        }
        return false;
    }
}

// for case like "a" vs ""  => true    "a" vs "a"   return false
return s != t;


///////////////////Method 2 :construct memo matrix ///////
//                  null 
//                   0  1 2 3 ... len1
// pre fill the null 0  
for (int i = 0; i <= len1; i++)
{
    res[i,0] = i;
}

for (int j = 0; j <= len2; j++)
{
    res[0,j] = j;
}

for (int i = 1; i <= len1; i++)
{
    for (int j = 1; j <= len2; j++)
    {
                    
        if (s1[i-1] == s2[j-1])
        {
            res[i, j] = res[i - 1, j - 1];  //* must use diag to take previous [i-1,j-1] best conclude steps
        }
        else
        {
            int minOfTopToLeftCorner = Math.Min(res[i - 1, j - 1], Math.Min(res[i - 1, j], res[i, j - 1]));
            res[i, j] = minOfTopToLeftCorner + 1;
        }
    }
}



/// 302. Smallest Rectangle Enclosing Black Pixels
/// https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/description/
/// An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.
/// 
/// Example:
/// 
/// Input:
/// [
///   "0010",
///   "0110",
///   "0100"
/// ]
///         and x = 0, y = 2
/// 
/// Output: 6
/// sol:
/// use BFS to find the max min corners
while(que.Count > 0)
{
    var curr = que.Dequeue();
                
    foreach (var delta in deltas)
    {
        int nx = curr.x + delta.x;
        int ny = curr.y + delta.y;

        if (nx >=0 && nx <lenX && ny >=0 && ny <lenY && image[nx,ny] == '1' && !visited[nx,ny])
        {
            que.Enqueue(new LocInfo(nx,ny));                              // (0,0)   x 
            visited[nx, ny] = true;    // yic must be here       for case    (1,0)  (1,1)   queue(1,0)  which enqueue(1,1) and (0,0)  will cause (0,1) into queue twice.  
            UpdateCorner(nx, ny);
        }
    }
}


/// 91
/// https://leetcode.com/problems/decode-ways/description/
/// http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-91-decode-ways/
/// A message containing letters from A-Z is being encoded to numbers using the following mapping: 
///'A' -> 1
///'B' -> 2
///...
///'Z' -> 26
///Given an encoded message containing digits, determine the total number of ways to decode it.
///For example,
///Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12). 
///The number of ways decoding "12" is 2.  
public int NumDecodings(string s)
{
    if (string.IsNullOrEmpty(s))
    {
        return 1;
    }

    int[] F = new int[(s.Length + 1)];    // yic  n+1  to handle pre case
    F[0] = 1;     // empty string as 1 decode ways

    for (int i = 1; i <= s.Length; i++)
    {

        F[i] = 0;

        if ((i-2) >=0 && isValid2Char(s, i-2))
        {
            F[i] += F[i - 2];
        }

        if (isValid1Char(s, i-1))
        {
            F[i] += F[i - 1];
        }
    }

    return F[s.Length];

}


/// 361
/// https://leetcode.com/problems/bomb-enemy/description/
/// 
/// iven a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0' (the number zero), return the maximum enemies you can kill using one bomb.
/// The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.
/// Note that you can only put the bomb at an empty cell.
/// 
/// Example:
/// For the given grid
/// 
/// 0 E 0 0
/// E 0 W E
/// 0 E 0 0
/// 
/// return 3. (Placing a bomb at (1,1) kills 3 enemies)
/// 
/// Note that you can only put the bomb at an empty cell.
/// 
/// sol: 
/// 
/// use 4 memo matrix to accum 4 directions   so , at(i,j)  just lookup the 4 matrix as O(1) time


/// 92
/// http://www.lintcode.com/en/problem/backpack/
/// Given n items with size Ai, an integer m denotes the size of a backpack. How full you can fill this backpack?
/// 
/// If we have 4 items with size [2, 3, 5, 7], the backpack size is 11, we can select [2, 3, 5], so that the max size we can fill this backpack is 10. If the backpack size is 12. we can select [2, 3, 7] so that we can fulfill the backpack.
/// You function should return the max size we can fill in the given backpack.
/// 
/// not sure which W can be true, so need to check each weight
/// 
/// F[i,W] = F[i-1,W]  || F[i-1, W - P[i-1]]    maxWeight is when F[N, maxWeight] == true;
/// 
/// can also use F[w][i] += F[w - A[i - 1]][i - 1];  and check
/// 
 [JavaCode] 

int N = A.length;
boolean[][] F = new boolean[m+1][N + 1];
F[0][0] = true;

int ans = 0;
for (int i = 1; i <= A.length; i++)
{
    for (int w = 0; w <= m; w++)
    {
        F[w][i] = F[w][i-1];        <-- important, without previous item, w can be reached
        if (w - A[i - 1] >= 0)
        {
            F[w][i] |= F[w - A[i - 1]][i - 1];
        }
        
		// update max w
        if (F[w][i] == true)
        {
            ans = w;
        }
    }
}

return ans;


/// 474. Ones and Zeroes
/// https://leetcode.com/problems/ones-and-zeroes/description/
/// In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.
///For now, suppose you are a dominator of m 0s and n 1s respectively.On the other hand, there is an array with strings consisting of only 0s and 1s.
///
///Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s.Each 0 and 1 can be used at most once.
///
///
///Note:
///The given numbers of 0s and 1s will both not exceed 100
///The size of given string array won't exceed 600.
///Example 1:
///Input: Array = { "10", "0001", "111001", "1", "0"}, m = 5, n = 3
///Output: 4
// F[i][m][n] = max (  F[i-1][m][n]     <--  skip current
//                     F[i-1][m-"a0_i-1"][n-"a1_i-1"]    <-- take current ) 


/// 161. One Edit Distance
/// https://leetcode.com/problems/one-edit-distance/description/
/// Given two strings S and T, determine if they are both one edit distance apart.
while (i >=0 && j >=0)
{
    if (s[i] == t[j])
    {
        i--;
        j--;
    }
    else
    {
        // delete case
        if (s.Substring(0, i) == t.Substring(0,j+1))   // yic note both s   i for len  current len-1, j+1 is totla len
        {
            return true;
        }
        // insert case
        else if ((s.Substring(0,i+1) + t[j]) == t.Substring(0, j + 1))
        {
            return true;
        }
        // replace case
        else if ((s.Substring(0,i) + t[j]) == t.Substring(0, j + 1))
        {
            return true;
        }
        return false;
    }
}

/// Given a string S and a string T, count the number of distinct subsequences of S which equals T.
/// A subsequence of a string is a new string which is formed from the original string by deleting some(can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).
/// 
/// Here is an example:
/// S = "rabbbit", T = "rabbit"
/// 
/// Return 3.
/// 
/// Sol:
/// DFS + memo  visit[i,j]   when if S[i] = T[j] move i, j, otherwise move i at curr level
if(i >=M && j < N)
{
    // cannot find char to compare in A, B not finish
    return 0;
}
else if (j >= N)
{
    // exceed B, match happen
    return 1;
}

if (visited[i,j])
{
    return F[i, j];
}

int count = 0;

for (int k = i; k < M; k++)
{
    if (s[k] == t[j])
    {
        count += NumDistinckHelper(s, t, visited, F, k + 1, j + 1, M,N);
    }
}

F[i, j] = count;

visited[i, j] = true;

return F[i, j];


/// 97. Interleaving String
/// https://leetcode.com/problems/interleaving-string/description/
/// Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.
/// 
/// For example,
/// Given:
/// s1 = "aabcc",
/// s2 = "dbbca",
/// 
/// When s3 = "aadbbcbcac", return true.
/// When s3 = "aadbbbaccc", return false.
/// 
/// F[i,j] = F[i-1,j] && X[i+j-1] == A[i-1] || F[i,j-1] && X[i+j-1] == B[j-1]