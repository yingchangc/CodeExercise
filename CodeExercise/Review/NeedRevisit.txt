
// <summary>
/// 186. Reverse Words in a String II
/// https://leetcode.com/problems/reverse-words-in-a-string-ii/description/
///  Given an input string, reverse the string word by word.A word is defined as a sequence of non-space characters.
/// 
/// The input string does not contain leading or trailing spaces and the words are always separated by a single space.
/// 
/// For example,
/// Given s = "the sky is blue",
/// return "blue is sky the".
/// 
/// sol:
/// 
/// step1 mirror all "eulb si yks eht"
/// step2 mirror each word    note: can mirror space
// step 2 rotate each word

[code]
int len = str.Length;
int left = 0;
int right = 0;
while (left < len)
{
    if (right == len || str[right] == ' ')
    {
        Rotate(str, left, right - 1);

        // reset left and right
        right = right + 1;   // skip curr space
        left = right;
    }
    else
    {
        right++;
    }
}




/// <summary>
/// 680
/// https://leetcode.com/problems/valid-palindrome-ii/description/
/// Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.
///Example 1:
///Input: "aba"
///Output: True
///Example 2:
///Input: "abca"
///Output: True
///Explanation: You could delete the character 'c'.
///Note:
///The string will only contain lowercase characters a-z.The maximum length of the string is 50000.
///
/// Sol:
/// 
/// check if curr string can be palindrome.
/// if not, remove left char || remove right char and see

[code]
if (!hasMismatch)
{
    return true;
}
else
{
    return simpleValidPalindrome(s.Substring(left, (right - left)))
        || simpleValidPalindrome(s.Substring(left + 1, (right - left)));



/// <summary>
/// https://www.lintcode.com/problem/implement-strstr/description
/// 13. Implement strStr()
/// For a given source string and a target string, you should output the first index(from 0) of target string in source string.
/// 
/// If target does not exist in source, just return -1.
/// 
/// Example
/// If source = "source" and target = "target", return -1.
/// 
/// If source = "abcdabcdefg" and target = "bcd", return 1.
///  
     Sol: corner condition like source or target is null

O(n^2)

for(int i=0; i <= (lenSource-lenTarget); i++)
{
    if (containsTarget(source, target, i, lenTarget))
    {
        return i;
    }
}

(O(M+N))

Sol: use hash  and walk through source until find the same len of the target and compare with target hash
(1)first to find target (smaller string) hash
foreach (char c in target)
{
    targetHash = (targetHash * 31 + c) % HashSlots;
}

(2) 
if i > target.length, we need to substract (-) the highest bit by follow hash and prepare to new lower bit to add to hash
get higest bit
for(int i = 1; i <=targetLen; i++)
{
    hash = (hash * 31) % HashSlots;
}


// curr len is > target, need to remove high bit
for (int i = 0; i < slen; i++)
{
    // (a*31*31 + b*31 + c)  % 5
    sourceSubStrHash = (sourceSubStrHash * 31 + source[i]) % HashSlots;

    // now we have full length of target, check if first match. 
    if (i==(target.Length-1) && sourceSubStrHash == targetHash)
    {
        return i - target.Length + 1;
    }
    // abc  + d,  remove the highest hash so we can add a newer low bit to hash (keep the same lenght as target) 
    if (i >= target.Length)
    {

        // substract the highest bit number
        //sourceSubStrHash -= ((source[i-targetlen] * 31 ^ (target.Length))%HashSlots);    // might overflow

        sourceSubStrHash -= ((source[i-target.Length] * highestpower)%HashSlots);

        if (sourceSubStrHash < 0)
        {
            sourceSubStrHash += HashSlots;
        }

        if (sourceSubStrHash == targetHash)
        {
            // need to double confirm with reach char compare, to prevent hash collision
            if (source.Substring(i-target.Length+1, target.Length).Equals(target) )
            {
                return i - target.Length + 1;
            }                
        }

    }
}



//235
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
// O(sqrt(N))
[CODE]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime
{
    while (num%i ==0)
    {
        ans.Add(i);
        num /= i;
    }
}

if (num > 1)
{
    ans.Add(num);
}



/// 50. Pow(x, n)
/// https://leetcode.com/problems/powx-n/description/
/// Implement pow(x, n), which calculates x raised to the power n (xn).
else if (n < 0)
{
    // yic
    //max 2147483647
    //min -2147483648
    if (n == Int32.MinValue)     
    {
        return MyPow(Math.Abs(1 / x), Int32.MaxValue);  // -2147483648  -> 2147483647   if - value, the final is positive
    }
    return MyPow(1 / x, -n);
}  

private double powerHelper(double x, int n)
{
    if (n == 1)
    {
        return x;
    }
    double half = powerHelper(x, n / 2);

    if (n%2 == 0)
    {
        return half * half;
    }

    return half * half * x;

}       


/// lint 140 fast power
///  https://www.lintcode.com/problem/fast-power/description
///  Calculate the a^n % b where a, b and n are all 32bit integers.
///  For 2^31 % 3 = 2
[code]
hanle a=0  n = 0 case.
Then

long product = fastPowerSolver(a, b, n / 2);
product = (product * product) %b;
if (n%2 == 0)
{
    return (int)product;
}
return (int)((product * a) %b);


/// 585. Maximum Number in Mountain Sequence
/// https://www.lintcode.com/en/old/problem/maximum-number-in-mountain-sequence/
/// 
/// Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.
/// Example
/// Given nums = [1, 2, 4, 8, 6, 3] return 8
/// Given nums = [10, 9, 8, 7], return 10 
[code]
while((left + 1) < right)
{
    // must be at least 3 elem to check
    int mid = left + (right - left) / 2;

    if (nums[mid-1] < nums[mid] && nums[mid] > nums[mid+1])     // yic  check mid-1  mid mid+1   not left, right
    {
        return nums[mid];
    }
    else if (nums[mid-1] <= nums[mid])
    {
        left = mid;
    }
    else
    {
        right = mid;
    }
}
// when out, it must be on the left/right edge
return Math.Max(nums[left], nums[right]);



/// 153
/// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e.,  [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
case     4 5 6 [0] "1" 2 3
case     4 5 6 [7] 8 9 "2"

/// Find the minimum element.
/// use binary search, and use "midV vs arr[right]""
///   smaller => go left to  get smallest,  bigger => go right
[code]
while((left +1) < right)
{
    int mid = left + (right - left) / 2;

    // yic  find smallest, check  mid and right
    // mid < right  (ascending),  go left to fiind min
    if (nums[mid] <= nums[right])
    {
        right = mid;
    }
    else
    {
        // 3 [4] 5 2
        left = mid;
    }
}

return nums[left] < nums[right] ? nums[left] : nums[right];



/// <summary>
/// 33. Search in Rotated Sorted Array
/// https://leetcode.com/problems/search-in-rotated-sorted-array/description/
/// Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
/// (i.e., [0,1,2,4,5,6,7]
///         might become[4, 5, 6, 7, 0, 1, 2]).
/// 
/// You are given a target value to search.If found in the array return its index, otherwise return -1.
/// 
/// You may assume no duplicate exists in the array.
case     4 5 6 [0] 1 2 3
case     4 5 6 [7] 8 9 2
[code]
while(left +1 < right)
{
    int mid = left + (right - left)/2;
    if (nums[mid] == target)
    {
        return mid;
    }
    // ascendint region
    if (nums[mid] < nums[right])
    {
        if (nums[mid] <= target && target <= nums[right])
        {
            left = mid;
        }
        else
        {
            right = mid;
        }
    }
    else
    {
        //3 4 [5] 6 1
        if (nums[left] <= target && target <= nums[mid])
        {
            right = mid;
        }
            else
        {
            left = mid;
        }
    }

}

if (nums[left] == target)
{
    return left;
}
else if (nums[right] == target)
{
    return right;
}
return -1;



//235
//Prime Factorization
//https://www.lintcode.com/problem/prime-factorization/description
// Given 10, return [2, 5].
//Given 660, return [2, 2, 3, 5, 11].
[code]
// 34,   sqrt = 5   i = 2~5 check, any thing > 5 must be prime, otherwise, a smaller one should make it small
for (int i = 2; i*i <= num; i++)    // yic sqrt   34  after sqrt, if != 1, the rest must be a prime



/// 215. Kth Largest Element in an Array
/// https://leetcode.com/problems/kth-largest-element-in-an-array/description/
/// Find the kth largest element in an unsorted array. Note that it is the 
/// kth largest element in the sorted order, not the kth distinct element.
/// 
/// Example 1:
/// 
/// Input: [3,2,1,5,6,4]
///         and k = 2
/// Output: 5
/// Example 2:

[code]   k is the kIndex (0 based) not kth


if (start >= end)
{
    return nums[start];
}
int left = start;
int right = end;

int pivot = nums[start + (end - start) / 2];

while(left <= right)
{
    while(left <= right && nums[left] > pivot)
    {
        left++;
    }
    while (left <= right && nums[right] < pivot)
    {
        right--;
    }

    if (left <= right)
    {
        swap(nums, left++, right--);
    }
}

if (start <= k && k <= right)
{
    return SelectionSort(nums, k, start, right);
}
else if (left <= k && k<=end)
{
    return SelectionSort(nums, k, left, end);
}
else
{
    return nums[(left + right) / 2];
}



/// <summary>
/// 228. Middle of Linked List

/// https://www.lintcode.com/problem/middle-of-linked-list/description
/// Given 1->2->3, return the node with value 2.
/// Given 1->2, return the node with value 1.
[code]  fast.next.next != null to prevent move on for odd case
 
while (fast!=null && fast.next !=null && fast.next.next!=null)
{
    slow = slow.next;
    fast = fast.next.next;
}


/// lint 57. 3Sum
///https://www.lintcode.com/problem/3sum/description
///Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in 
///the array which gives the sum of zero.
///Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
///The solution set must not contain duplicate triplets.
///
/// For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:
/// (-1, 0, 1)
/// (-1, -1, 2)     
/// 
/// sol:
/// 
/// cannot use hashset as it does not rember the index and if it has appear before,
/// so use 2 pointers,  if first number exist, go right
///  if second number (after add to answer) exists before, go right

[code]
 // sort for the ans requirement (list to be ascending)
Array.Sort(numbers);
int len = numbers.Length;

List<List<int>> ans = new List<List<int>>();

for (int i =0; i <len-2; i++)
{
    if (i > 0 && numbers[i]==numbers[i-1])
    {
        continue;

        // YIC (numbers[i-1], numbers[i]), numbers[i+1]     if num i-1  == num i, i-1 has done all the possible combination
    }

    // apply two sum
    int target = 0 - numbers[i];

    int left = i + 1;
    int right = len-1;

    while (left < right)
    {
        if ((numbers[left] + numbers[right]) == target)
        {
            ans.Add(new List<int>() { numbers[i], numbers[left], numbers[right] });

            left++;
                        
            // yic Note: after add to ans, need to keep go right to de-duplicate   [1,1,1],1  target =3
            while (left < len && numbers[left] == numbers[left-1])
            {
                //just need to move left, because dup right cannot fullfil after
                left++;
            }
        }
        else if ((numbers[left] + numbers[right]) < target)
        {
            //yic just need to move left
            left++;
        }
        else
        {
            right--;
        }

    }
}