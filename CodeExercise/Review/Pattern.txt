
/// <summary>
/// 143. Sort Colors II
/// https://www.lintcode.com/problem/sort-colors-ii/description
/// Description
/// Given an array of n objects with k different colors(numbered from 1 to k), sort them so that objects of the same 
/// color are adjacent, with the colors in the order 1, 2, ... k.
/// 
/// Example
/// Given colors =[3, 2, 2, 1, 4], k = 4, your code should sort colors in-place to[1, 2, 2, 3, 4].
/// 
/// Sol.
/// 
/// QSort

private void qkSort(int[] colors, int k, int start, int end)
{
    if (colors == null || start >=end)
    {
        return;
    }

    int left = start;
    int right = end;

    int pivot = colors[(start + (end - start) / 2)];

    while(left <= right)
    {
        while(left <= right && colors[left] < pivot)
        {
            left++;
        }
        while(left <= right && colors[right] > pivot)
        {
            right--;
        }

        if (left <= right)
        {
            swap(colors, left++, right--);
        }
    }

    qkSort(colors, k, start, right);
    qkSort(colors, k, left, end);
}



//////////////////////
// Binary Search
////////////////////
public int findPosition(int[] nums, int target) {
if (nums == null || nums.length == 0) {
    return -1;
}
        
int start = 0, end = nums.length - 1;
// 要点1: start + 1 < end
while (start + 1 < end) {
// 要点2：start + (end - start) / 2
    int mid = start + (end - start) / 2;
    // 要点3：=, <, > 分开讨论，mid 不+1也不-1
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        start = mid;
    } else {
        end = mid;
    }
}
        
// 要点4: 循环结束后，单独处理start和end
if (nums[start] == target) {
    return start;
}
if (nums[end] == target) {
    return end;
}
return -1;
}