
/// <summary>
/// 143. Sort Colors II
/// https://www.lintcode.com/problem/sort-colors-ii/description
/// Description
/// Given an array of n objects with k different colors(numbered from 1 to k), sort them so that objects of the same 
/// color are adjacent, with the colors in the order 1, 2, ... k.
/// 
/// Example
/// Given colors =[3, 2, 2, 1, 4], k = 4, your code should sort colors in-place to[1, 2, 2, 3, 4].
/// 
/// Sol.
/// 
/// QSort

private void qkSort(int[] colors, int k, int start, int end)
{
    if (colors == null || start >=end)
    {
        return;
    }

    int left = start;
    int right = end;

    int pivot = colors[(start + (end - start) / 2)];

    while(left <= right)
    {
        while(left <= right && colors[left] < pivot)
        {
            left++;
        }
        while(left <= right && colors[right] > pivot)
        {
            right--;
        }

        if (left <= right)
        {
            swap(colors, left++, right--);
        }
    }

    qkSort(colors, k, start, right);
    qkSort(colors, k, left, end);
}



//////////////////////
// Binary Search
////////////////////
public int findPosition(int[] nums, int target) {
if (nums == null || nums.length == 0) {
    return -1;
}
        
int start = 0, end = nums.length - 1;
// 要点1: start + 1 < end
while (start + 1 < end) {
// 要点2：start + (end - start) / 2
    int mid = start + (end - start) / 2;
    // 要点3：=, <, > 分开讨论，mid 不+1也不-1
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        start = mid;
    } else {
        end = mid;
    }
}
        
// 要点4: 循环结束后，单独处理start和end
if (nums[start] == target) {
    return start;
}
if (nums[end] == target) {
    return end;
}
return -1;
}



/// 228. Middle of Linked List
/// https://www.lintcode.com/problem/middle-of-linked-list/description
/// Given 1->2->3, return the node with value 2.
/// Given 1->2, return the node with value 1.
[code]
var slow = head;
var fast = head;
while (fast!=null && fast.next !=null && fast.next.next!=null)
{
    slow = slow.next;
    fast = fast.next.next;
}
return slow;


/// 142
/// https://leetcode.com/problems/linked-list-cycle-ii/description/
/// Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
/// ref https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle
/// Note: Do not modify the linked list.
/// 
/// sol
/// phase 1
/// Distance travelled by slowPointer before meeting =x+y
/// Distance travelled by fastPointer before meeting = (x + y + z) + y = x + 2y + z
/// 
/// phase2
/// Since fastPointer travels with double the speed of slowPointer, and time is constant for both when the reach the meeting point. So by using simple speed, time and distance relation (slowPointer traveled half the distance):

/// 2∗dist(slowPointer)2(x+y) = dist(fastPointer)    
/// 2(x+y) = x + 2y + z    => 2x = x+z     => x=z
/// 
/// so just walk from beginnng and slow point, when meet, it is start cycle point
[code]
 ListNode slow = head;
ListNode fast = head;

//phase 1 find meet point
while (fast != null && fast.next != null && fast.next.next != null)
{
    slow = slow.next;
    fast = fast.next.next;

    if (slow == fast)
    {
        break;
    }
}

if (fast == null || fast.next == null || fast.next.next == null)
{
    return null;
}

// phase 2
ListNode start = head;
while (start != slow)
{
    start = start.next;
    slow = slow.next;
}

return start;