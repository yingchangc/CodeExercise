
/// <summary>
/// 143. Sort Colors II
/// https://www.lintcode.com/problem/sort-colors-ii/description
/// Description
/// Given an array of n objects with k different colors(numbered from 1 to k), sort them so that objects of the same 
/// color are adjacent, with the colors in the order 1, 2, ... k.
/// 
/// Example
/// Given colors =[3, 2, 2, 1, 4], k = 4, your code should sort colors in-place to[1, 2, 2, 3, 4].
/// 
/// Sol.
/// 
/// QSort

private void qkSort(int[] colors, int k, int start, int end)
{
    if (colors == null || start >=end)
    {
        return;
    }

    int left = start;
    int right = end;

    int pivot = colors[(start + (end - start) / 2)];

    while(left <= right)
    {
        while(left <= right && colors[left] < pivot)
        {
            left++;
        }
        while(left <= right && colors[right] > pivot)
        {
            right--;
        }

        if (left <= right)
        {
            swap(colors, left++, right--);
        }
    }

    qkSort(colors, k, start, right);
    qkSort(colors, k, left, end);
}



//////////////////////
// Binary Search
////////////////////
public int findPosition(int[] nums, int target) {
if (nums == null || nums.length == 0) {
    return -1;
}
        
int start = 0, end = nums.length - 1;
// 要点1: start + 1 < end
while (start + 1 < end) {
// 要点2：start + (end - start) / 2
    int mid = start + (end - start) / 2;
    // 要点3：=, <, > 分开讨论，mid 不+1也不-1
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        start = mid;
    } else {
        end = mid;
    }
}
        
// 要点4: 循环结束后，单独处理start和end
if (nums[start] == target) {
    return start;
}
if (nums[end] == target) {
    return end;
}
return -1;
}



/// 228. Middle of Linked List
/// https://www.lintcode.com/problem/middle-of-linked-list/description
/// Given 1->2->3, return the node with value 2.
/// Given 1->2, return the node with value 1.
[code]
var slow = head;
var fast = head;
while (fast!=null && fast.next !=null && fast.next.next!=null)
{
    slow = slow.next;
    fast = fast.next.next;
}
return slow;


/// 142
/// https://leetcode.com/problems/linked-list-cycle-ii/description/
/// Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
/// ref https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle
/// Note: Do not modify the linked list.
/// 
/// sol
/// phase 1
/// Distance travelled by slowPointer before meeting =x+y
/// Distance travelled by fastPointer before meeting = (x + y + z) + y = x + 2y + z
/// 
/// phase2
/// Since fastPointer travels with double the speed of slowPointer, and time is constant for both when the reach the meeting point. So by using simple speed, time and distance relation (slowPointer traveled half the distance):

/// 2∗dist(slowPointer)2(x+y) = dist(fastPointer)    
/// 2(x+y) = x + 2y + z    => 2x = x+z     => x=z
/// 
/// so just walk from beginnng and slow point, when meet, it is start cycle point
[code]
 ListNode slow = head;
ListNode fast = head;

//phase 1 find meet point
while (fast != null && fast.next != null && fast.next.next != null)
{
    slow = slow.next;
    fast = fast.next.next;

    if (slow == fast)
    {
        break;
    }
}

if (fast == null || fast.next == null || fast.next.next == null)
{
    return null;
}

// phase 2
ListNode start = head;
while (start != slow)
{
    start = start.next;
    slow = slow.next;
}

return start;



/// 102. Binary Tree Level Order Traversal
/// https://leetcode.com/problems/binary-tree-level-order-traversal/description/
/// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
[code]
public IList<IList<int>> LevelOrder(TreeNode root)
{
    List<List<int>> ans = new List<List<int>>();
    Queue<TreeNode> queue = new Queue<TreeNode>();

    if (root == null)
    {
        return ans.ToArray();
    }

    queue.Enqueue(root);

    while(queue.Count >0)
    {
        // each time current queue contains all node of this level
        int size = queue.Count;

        List<int> levelAns = new List<int>();

        for(int i = 0; i <size; i++)
        {
            var top = queue.Dequeue();

            levelAns.Add(top.val);

            if (top.left != null)
            {
                queue.Enqueue(top.left);
            }

            if (top.right != null)
            {
                queue.Enqueue(top.right);
            }
        }

        ans.Add(levelAns); 
    }

    return ans.ToArray();
}


//615. Course Schedule
//There are a total of n courses you have to take, labeled from 0 to n - 1.
//Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
// (1) compute the inbound count and build child graph (so that we can traverse to next child)
Dictionary<int, int> inLookup = new Dictionary<int, int>();   // node , inbound count
Dictionary<int, List<int>> childLookup = new Dictionary<int, List<int>>();   // parent-> children
// (2) put no inbound to queue
// (3) traverse to next course, --child inbound, 0 then put to queue, finish when queue empty


//BFS
// T 指代任何你希望存储的类型
Queue<T> queue = new LinkedList<>();
Set<T> set = new HashSet<>();

set.add(start);
queue.offer(start);
while (!queue.isEmpty()) {
    int size = queue.size();
    for (int i = 0; i < size; i++) {
        T head = queue.poll();
        for (T neighbor : head.neighbors) {
            if (!set.contains(neighbor)) {
                set.add(neighbor);
                queue.offer(neighbor);
            }
        }
    }
}


/// lint 611 Knight Shortest Path
/// https://www.lintcode.com/problem/knight-shortest-path/description
/// Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.
/// Return -1 if knight can not reached.
/// 
/// If the knight is at (x, y), he can get to the following positions in one step:
/// (x + 1, y + 2)
/// (x + 1, y - 2)
/// (x - 1, y + 2)
/// (x - 1, y - 2)
/// (x + 2, y + 1)
/// (x + 2, y - 1)
/// (x - 2, y + 1)
/// (x - 2, y - 1)
//Sol :use BFS level order to get min steps count
[code]
step = 0;
visited[source.x, source.y] = true;

while(queue.Count > 0)
{
    int levelSize = queue.Count;

    for (int i = 0; i <levelSize; i++)
    {
        var curr = queue.Dequeue();

        if (curr.x == destination.x && curr.y == destination.y)
        {
            return steps;    // yic check  source == destination
        }

        // look for 8 surrandings 
        foreach (var deltaP in deltas)
        {
            var newPoint = new Point(curr.x + deltaP.x, curr.y + deltaP.y);

            if (newPoint.x >= 0 && newPoint.x < xLen && newPoint.y >= 0 && newPoint.y < yLen
                && grid[newPoint.x, newPoint.y] == false   // no block
                && visited[newPoint.x, newPoint.y] == false)
            {
                visited[newPoint.x, newPoint.y] = true;   //yic  true first
                queue.Enqueue(newPoint);
            }
        }
    }

    steps++;  // yic, step ++ here   ex, source==dest
}


 /// 127 Topological Sorting
/// https://www.lintcode.com/problem/topological-sorting/description
/// Given an directed graph, a topological order of the graph nodes is defined as follow:

/// For each directed edge A -> B in graph, A must before B in the order list.
/// The first node in the order can be any node in the graph with no nodes direct to it.
/// Find any topological order for the given graph.

[code]
public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        // map 用来存储所有节点的入度，这里主要统计各个点的入度
        HashMap<DirectedGraphNode, Integer> map = new HashMap();
        for (DirectedGraphNode node : graph) {
            for (DirectedGraphNode neighbor : node.neighbors) {
                if (map.containsKey(neighbor)) {
                    map.put(neighbor, map.get(neighbor) + 1);
                } else {
                    map.put(neighbor, 1); 
                }
            }
        }

        // 初始化拓扑序列为空
        ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();

        // 把所有入度为0的点，放到BFS专用的队列中
        Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        for (DirectedGraphNode node : graph) {
            if (!map.containsKey(node)) {
                q.offer(node);
                result.add(node);
            }
        }

        // 每次从队列中拿出一个点放到拓扑序列里，并将该点指向的所有点的入度减1
        while (!q.isEmpty()) {
            DirectedGraphNode node = q.poll();
            for (DirectedGraphNode n : node.neighbors) {
                map.put(n, map.get(n) - 1);
                // 减去1之后入度变为0的点，也放入队列
                if (map.get(n) == 0) {
                    result.add(n);
                    q.offer(n);
                }
            }
        }

        return result;
    }


////////////////
分治法解决问题的思路
先让左右子树去解决同样的问题，然后得到结果之后，再整合为整棵树的结果。    leftchild, rightChild len

遍历法解决问题的思路
通过前序/中序/后序的某种遍历，游走整棵树，通过一个全局变量或者传递的参数来记录这个过程中所遇到的点和需要计算的结果。

inorder, left, mid right, ex. use gloal is Valid flag 


两种方法的区别
从程序实现角度分治法的递归函数，通常有一个返回值，遍历法通常没有。