
/// <summary>
/// 143. Sort Colors II
/// https://www.lintcode.com/problem/sort-colors-ii/description
/// Description
/// Given an array of n objects with k different colors(numbered from 1 to k), sort them so that objects of the same 
/// color are adjacent, with the colors in the order 1, 2, ... k.
/// 
/// Example
/// Given colors =[3, 2, 2, 1, 4], k = 4, your code should sort colors in-place to[1, 2, 2, 3, 4].
/// 
/// Sol.
/// 
/// QSort

private void qkSort(int[] colors, int k, int start, int end)
{
    if (colors == null || start >=end)
    {
        return;
    }

    int left = start;
    int right = end;

    int pivot = colors[(start + (end - start) / 2)];

    while(left <= right)
    {
        while(left <= right && colors[left] < pivot)
        {
            left++;
        }
        while(left <= right && colors[right] > pivot)
        {
            right--;
        }

        if (left <= right)
        {
            swap(colors, left++, right--);
        }
    }

    qkSort(colors, k, start, right);
    qkSort(colors, k, left, end);
}



//////////////////////
// Binary Search
////////////////////
public int findPosition(int[] nums, int target) {
if (nums == null || nums.length == 0) {
    return -1;
}
        
int start = 0, end = nums.length - 1;
// 要点1: start + 1 < end
while (start + 1 < end) {
// 要点2：start + (end - start) / 2
    int mid = start + (end - start) / 2;
    // 要点3：=, <, > 分开讨论，mid 不+1也不-1
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        start = mid;
    } else {
        end = mid;
    }
}
        
// 要点4: 循环结束后，单独处理start和end
if (nums[start] == target) {
    return start;
}
if (nums[end] == target) {
    return end;
}
return -1;
}



/// 228. Middle of Linked List
/// https://www.lintcode.com/problem/middle-of-linked-list/description
/// Given 1->2->3, return the node with value 2.
/// Given 1->2, return the node with value 1.
[code]
var slow = head;
var fast = head;
while (fast!=null && fast.next !=null && fast.next.next!=null)
{
    slow = slow.next;
    fast = fast.next.next;
}
return slow;


/// 142
/// https://leetcode.com/problems/linked-list-cycle-ii/description/
/// Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
/// ref https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle
/// Note: Do not modify the linked list.
/// 
/// sol
/// phase 1
/// Distance travelled by slowPointer before meeting =x+y
/// Distance travelled by fastPointer before meeting = (x + y + z) + y = x + 2y + z
/// 
/// phase2
/// Since fastPointer travels with double the speed of slowPointer, and time is constant for both when the reach the meeting point. So by using simple speed, time and distance relation (slowPointer traveled half the distance):

/// 2∗dist(slowPointer)2(x+y) = dist(fastPointer)    
/// 2(x+y) = x + 2y + z    => 2x = x+z     => x=z
/// 
/// so just walk from beginnng and slow point, when meet, it is start cycle point
[code]
 ListNode slow = head;
ListNode fast = head;

//phase 1 find meet point
while (fast != null && fast.next != null && fast.next.next != null)
{
    slow = slow.next;
    fast = fast.next.next;

    if (slow == fast)
    {
        break;
    }
}

if (fast == null || fast.next == null || fast.next.next == null)
{
    return null;
}

// phase 2
ListNode start = head;
while (start != slow)
{
    start = start.next;
    slow = slow.next;
}

return start;



/// 102. Binary Tree Level Order Traversal
/// https://leetcode.com/problems/binary-tree-level-order-traversal/description/
/// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
[code]
public IList<IList<int>> LevelOrder(TreeNode root)
{
    List<List<int>> ans = new List<List<int>>();
    Queue<TreeNode> queue = new Queue<TreeNode>();

    if (root == null)
    {
        return ans.ToArray();
    }

    queue.Enqueue(root);

    while(queue.Count >0)
    {
        // each time current queue contains all node of this level
        int size = queue.Count;

        List<int> levelAns = new List<int>();

        for(int i = 0; i <size; i++)
        {
            var top = queue.Dequeue();

            levelAns.Add(top.val);

            if (top.left != null)
            {
                queue.Enqueue(top.left);
            }

            if (top.right != null)
            {
                queue.Enqueue(top.right);
            }
        }

        ans.Add(levelAns); 
    }

    return ans.ToArray();
}


//615. Course Schedule
//There are a total of n courses you have to take, labeled from 0 to n - 1.
//Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
// (1) compute the inbound count and build child graph (so that we can traverse to next child)
Dictionary<int, int> inLookup = new Dictionary<int, int>();   // node , inbound count
Dictionary<int, List<int>> childLookup = new Dictionary<int, List<int>>();   // parent-> children
// (2) put no inbound to queue
// (3) traverse to next course, --child inbound, 0 then put to queue, finish when queue empty


//BFS
// T 指代任何你希望存储的类型
Queue<T> queue = new LinkedList<>();
Set<T> set = new HashSet<>();

set.add(start);
queue.offer(start);
while (!queue.isEmpty()) {
    int size = queue.size();
    for (int i = 0; i < size; i++) {
        T head = queue.poll();
        for (T neighbor : head.neighbors) {
            if (!set.contains(neighbor)) {
                set.add(neighbor);
                queue.offer(neighbor);
            }
        }
    }
}


/// lint 611 Knight Shortest Path
/// https://www.lintcode.com/problem/knight-shortest-path/description
/// Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.
/// Return -1 if knight can not reached.
/// 
/// If the knight is at (x, y), he can get to the following positions in one step:
/// (x + 1, y + 2)
/// (x + 1, y - 2)
/// (x - 1, y + 2)
/// (x - 1, y - 2)
/// (x + 2, y + 1)
/// (x + 2, y - 1)
/// (x - 2, y + 1)
/// (x - 2, y - 1)
//Sol :use BFS level order to get min steps count
[code]
step = 0;
visited[source.x, source.y] = true;

while(queue.Count > 0)
{
    int levelSize = queue.Count;

    for (int i = 0; i <levelSize; i++)
    {
        var curr = queue.Dequeue();

        if (curr.x == destination.x && curr.y == destination.y)
        {
            return steps;    // yic check  source == destination
        }

        // look for 8 surrandings 
        foreach (var deltaP in deltas)
        {
            var newPoint = new Point(curr.x + deltaP.x, curr.y + deltaP.y);

            if (newPoint.x >= 0 && newPoint.x < xLen && newPoint.y >= 0 && newPoint.y < yLen
                && grid[newPoint.x, newPoint.y] == false   // no block
                && visited[newPoint.x, newPoint.y] == false)
            {
                visited[newPoint.x, newPoint.y] = true;   //yic  true first
                queue.Enqueue(newPoint);
            }
        }
    }

    steps++;  // yic, step ++ here   ex, source==dest
}


 /// 127 Topological Sorting
/// https://www.lintcode.com/problem/topological-sorting/description
/// Given an directed graph, a topological order of the graph nodes is defined as follow:

/// For each directed edge A -> B in graph, A must before B in the order list.
/// The first node in the order can be any node in the graph with no nodes direct to it.
/// Find any topological order for the given graph.

[code]
public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        // map 用来存储所有节点的入度，这里主要统计各个点的入度
        HashMap<DirectedGraphNode, Integer> map = new HashMap();
        for (DirectedGraphNode node : graph) {
            for (DirectedGraphNode neighbor : node.neighbors) {
                if (map.containsKey(neighbor)) {
                    map.put(neighbor, map.get(neighbor) + 1);
                } else {
                    map.put(neighbor, 1); 
                }
            }
        }

        // 初始化拓扑序列为空
        ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();

        // 把所有入度为0的点，放到BFS专用的队列中
        Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        for (DirectedGraphNode node : graph) {
            if (!map.containsKey(node)) {
                q.offer(node);
                result.add(node);
            }
        }

        // 每次从队列中拿出一个点放到拓扑序列里，并将该点指向的所有点的入度减1
        while (!q.isEmpty()) {
            DirectedGraphNode node = q.poll();
            for (DirectedGraphNode n : node.neighbors) {
                map.put(n, map.get(n) - 1);
                // 减去1之后入度变为0的点，也放入队列
                if (map.get(n) == 0) {
                    result.add(n);
                    q.offer(n);
                }
            }
        }

        return result;
    }


////////////////
分治法解决问题的思路
先让左右子树去解决同样的问题，然后得到结果之后，再整合为整棵树的结果。    leftchild, rightChild len

遍历法解决问题的思路
通过前序/中序/后序的某种遍历，游走整棵树，通过一个全局变量或者传递的参数来记录这个过程中所遇到的点和需要计算的结果。

inorder, left, mid right, ex. use gloal is Valid flag 


两种方法的区别
从程序实现角度分治法的递归函数，通常有一个返回值，遍历法通常没有。



///
/// 23. Merge k Sorted Lists
/// https://leetcode.com/problems/merge-k-sorted-lists/description/
/// Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
/// Example:
/// 
/// Input:
/// [
///   1->4->5,
///   1->3->4,
///   2->6
/// ]
/// Output: 1->1->2->3->4->4->5->6
// Java
[code]    
(1)  Priority Queue     O(nlog(k))
public class Solution {
    private Comparator<ListNode> ListNodeComparator = new Comparator<ListNode>() {
        public int compare(ListNode left, ListNode right) {
            return left.val - right.val;
        }
    };
    
    public ListNode mergeKLists(List<ListNode> lists) {
        if (lists == null || lists.size() == 0) {
            return null;
        }
        
        Queue<ListNode> heap = new PriorityQueue<ListNode>(lists.size(), ListNodeComparator);
        for (int i = 0; i < lists.size(); i++) {
            if (lists.get(i) != null) {         // yic incase listNode is null
                heap.add(lists.get(i));
            }
        }
        
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (!heap.isEmpty()) {
            ListNode head = heap.poll();
            tail.next = head;
            tail = head;
            if (head.next != null) {
                heap.add(head.next);
            }
        }
        return dummy.next;
    }
}


(2) Divide & Conquer   O(nlog(k))
/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List<ListNode> lists) {
        if (lists.size() == 0) {
            return null;
        }
        return mergeHelper(lists, 0, lists.size() - 1);
    }
    
    private ListNode mergeHelper(List<ListNode> lists, int start, int end) {
        if (start == end) {
            return lists.get(start);
        }
        
        int mid = start + (end - start) / 2;
        ListNode left = mergeHelper(lists, start, mid);
        ListNode right = mergeHelper(lists, mid + 1, end);
        return mergeTwoLists(left, right);
    }
    
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                tail.next = list1;
                tail = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                tail = list2;
                list2 = list2.next;
            }
        }
        if (list1 != null) {
            tail.next = list1;
        } else {
            tail.next = list2;
        }
        
        return dummy.next;
    }
}



/// 146 LRU cache
/// https://leetcode.com/problems/lru-cache/description/
/// Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
/// get(key) - Get the value(will always be positive) of the key if the key exists in the cache, otherwise return -1.
///put(key, value) - Set or insert the value if the key is not already present.When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
/// 
///LRUCache cache = new LRUCache(2 /* capacity */ );
///
///cache.put(1, 1);
///cache.put(2, 2);
///cache.get(1);       // returns 1

DummyHead <-> DummyTail

Dictionary<int, CacheNode> lookup;
int capacity;

private void detatch(CacheNode n)
{
    CacheNode pre = n.pre;
    CacheNode next = n.next;

    pre.next = next;
    next.pre = pre;
}

private void attachToHead(CacheNode n)
{
    CacheNode curr1st = head.next;   // yic
    head.next = n;

    n.pre = head;
    n.next = curr1st;

    curr1st.pre = n;
}




class Element {
    public int row, col, val;
    Element(int row, int col, int val) {
        this.row = row;
        this.col = col;
        this.val = val;
    }
}


/// 486. Merge K Sorted Arrays
/// 
/// https://www.lintcode.com/problem/merge-k-sorted-arrays/description
/// Given k sorted integer arrays, merge them into one sorted array.
/// 
/// Example
/// Given 3 sorted arrays:
/// 
/// 
/// [
///   [1, 3, 5, 7],
///   [2, 4, 6],
///   [0, 8, 9, 10, 11]
/// ]
/// return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].
/// 
/// Challenge
/// Do it in O(N log k).

Sol:

use element to record col, row, val
Ans array with totalElem  and insert each val

public class Solution {
    private Comparator<Element> ElementComparator = new Comparator<Element>() {
        public int compare(Element left, Element right) {
            return left.val - right.val;
        }
    };
    
    /**
     * @param arrays k sorted integer arrays
     * @return a sorted array
     */
    public int[] mergekSortedArrays(int[][] arrays) {
        if (arrays == null) {
            return new int[0];
        }
        
        int total_size = 0;
        Queue<Element> Q = new PriorityQueue<Element>(
            arrays.length, ElementComparator);
            
        for (int i = 0; i < arrays.length; i++) {
            if (arrays[i].length > 0) {
                Element elem = new Element(i, 0, arrays[i][0]);
                Q.add(elem);
                total_size += arrays[i].length;
            }
        }
        
        int[] result = new int[total_size];
        int index = 0;
        while (!Q.isEmpty()) {
            Element elem = Q.poll();
            result[index++] = elem.val;
            if (elem.col + 1 < arrays[elem.row].length) {
                elem.col += 1;
                elem.val = arrays[elem.row][elem.col];
                Q.add(elem);
            }
        }
        
        return result;
    }
}


/// https://www.lintcode.com/problem/top-k-largest-numbers/description
/// 544. Top k Largest Numbers
/// Given an integer array, find the top k largest numbers in it.
/// 
/// Example
/// Given[3, 10, 1000, -99, 4, 100] and k = 3.
///     Return[1000, 100, 10].
///     
/// 
/// Sol
/// (1) sort all array  nlogn
/// (2) use minheap and pop min if size > k so that in the end, we can get the largest k   nlogk
/// (3) selection sort  n+(klogk)   selection + sort answer
(2) 
 // use SortedList to mimic pq
SortedList<int, int> minheap = new SortedList<int, int>(new AscendingComarer());

for (int i = 0; i < nums.Length; i ++)
{
    minheap.Add(nums[i], 1);

    if (i >=k)
    {
        minheap.RemoveAt(0);
    }
}

int[] ans = new int[k];
int idx = k-1;
foreach(int n in minheap.Keys)
{
    ans[idx--] = n;
}

return ans;

(3)
 private void selectionSort(int[] nums, int start , int last, int k)
{
    if (start >= last)
    {
        return;
    }

    int left = start;
    int right = last; 
    int pivot = nums[(left + right) / 2];

    // sort from big to small
    while (left <= right)
    {
        while(left<=right && nums[left] > pivot)
        {
            left++;
        }

        while (left <= right && nums[right] < pivot)
        {
            right--;
        }

        if (left <= right)    // yic
        {
            int temp = nums[left];
            nums[left++] = nums[right];
            nums[right--] = temp;
        }
    }

    if (start <=k && k <=right)
    {
        selectionSort(nums, start, right, k);
    }
    else if (left <= k && k <= last)
    {
        selectionSort(nums, left, last, k);
    }
}


///606. Kth Largest Element II
///Find K-th largest element in an array. and N is much larger than k.

use minHeap,

1 2 3 4,   k = 3

1 2 3

1 2  3 (4)    pop

2 3 4,    3th largest is 2   so  peek is the answer


    PriorityQueue<Integer> q = new PriorityQueue<Integer>(k);
    for (int num : nums) {
        q.offer(num);
        if (q.size() > k) {
            q.poll();
        }
    }
    return q.peek();           largest is in the bottom of q,  top is the kth



/// 129. Rehashing
/// https://www.lintcode.com/problem/rehashing/description
/// C++/Java: if you directly calculate -4 % 3 you will get -1. You can use function: a % b = (a % b + b) % b to make it is a non negative integer.



/// 128
/// https://leetcode.com/problems/longest-consecutive-sequence/description/
/// Given an unsorted array of integers, find the length of the longest consecutive elements sequence. 
///        For example,
///        Given[100, 4, 200, 1, 3, 2],
///        The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. 
sol   O(n)

int maxLen = 1;

foreach(int n in nums)
{
    int currCount = 1;
    int temp = n;
    // lookfor Smallest in consecutive
    // only move on when smallest,   so only iterate once O(n)  in the end,
    if (!lookup.Contains(n-1))
    {
        while(lookup.Contains(temp+1))
        {
            currCount++;
            temp++;
            maxLen = Math.Max(maxLen, currCount);
        }
    }
}



/// lint 405 
/// https://www.lintcode.com/en/old/problem/submatrix-sum/
/// Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.
/// Given matrix
/// 
///ex,
// [
//  [1 ,5 ,7],
//  [3 ,7 ,-8],
//  [4 ,-8 ,9],
// ]
/// return [(1, 1), (2, 2)]

[code]
for (int j1 = 0; j1 <=M; j1++)    // 0~M
{
    for (int j2 = j1+1; j2 <= M; j2++)  //j1+1 ~M   because down right corner
    {
        for (int i = 0; i <= N; i++)      // 0~N    0  because we need dummy padding for compute "incude start idx"

private void preComputeSum(int[,] matrix, int[,] sumMatrix)
{
    int M = matrix.GetLength(0);
    int N = matrix.GetLength(1);

    // place padding
    for (int j = 0; j <=M; j++)
    {
        sumMatrix[j, 0] = 0;
    }

    for (int i = 0; i <= N; i++)
    {
        sumMatrix[0, i] = 0;
    }

    // compute sum from (left + top - top_left) + currLocValue
    for (int j = 1; j <=M; j++)
    {
        for (int i = 1; i <=N; i++)
        {
            sumMatrix[j, i] = sumMatrix[j - 1, i] + sumMatrix[j, i - 1] - sumMatrix[j - 1, i - 1] + matrix[j - 1, i - 1];
        }
    }
}



/// 38. Search a 2D Matrix II
/// https://leetcode.com/problems/search-a-2d-matrix-ii/description/
/// Write an efficient algorithm that searches for a value in an m x n matrix, return the occurrence of it.
/// 
/// This matrix has the following properties:
/// 
/// 
/// Integers in each row are sorted from left to right.
/// Integers in each column are sorted from up to bottom.
/// No duplicate integers in each row or column.
/// Example
///         Consider the following matrix:
/// 
/// 
///         [
///           [1, 3, 5, 7],
///           [2, 4, 7, 8],
///           [3, 5, 9, 10]
/// ]
/// Given target = 3, return 2.

[code]
int count = 0;
// start from left bottom
int r = rows - 1;
int c = 0;
            
while (r >=0 && c< cols)
{
    if (matrix[r, c] == target)
    {
        count++;
        r--;  // can only go up for smaller
    }
    else if (matrix[r, c] > target)
    {
        r--;
    }
    else
    {
        //matrix[r, c] < target
        c++;
    }
}




/// 378. Kth Smallest Element in a Sorted Matrix
/// Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
/// 
///         Note that it is the kth smallest element in the sorted order, not the kth distinct element.
/// 
///         Example:
/// 
/// matrix = [
///    [ 1,  5,  9],
///    [10, 11, 13],
///    [12, 13, 15]
/// ],
/// k = 8,
/// 
/// return 13.


//[sol]
pick two corners, (start and end) and choose midV and compute rank
int left = matrix[0, 0];
int right = matrix[M - 1, N - 1];  //(j,i)      

while (left < right)
{
    int mid = (left + right) / 2;
    int rank = countRank(matrix, mid);

    if (rank >= k)                 // note >=  use mid
    {
        right = mid;
    }
    else
    {
        left = mid + 1;    // note mid +1
    }
}

return left;


// count where mid rank, start from botton-left as moving point
private int countRank(int[,] matrix, int mid)
{
    int M = matrix.GetLength(0);   // for j
    int N = matrix.GetLength(1);   // for i
    int i = 0;
    int j = N - 1;

    int rank = 0;
    // move i, j
    while(i < N && j >= 0)
    {
        int debug = matrix[j, i];
        if (matrix[j,i] > mid)  // note  yic   [j,i]
        {
            j--;
        }
        else
        {
            rank +=( j + 1);  // i becasue consider all the to top +1 to include itself (check vertical)
            i++;
        }
    }

    return rank;
}



/// 209. Minimum Size Subarray Sum
/// https://www.lintcode.com/problem/minimum-size-subarray-sum/description
/// Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. 
/// If there isn't one, return 0 instead. 
/// For example, given the array[2, 3, 1, 2, 4, 3] and s = 7,
///  the subarray[4, 3] has the minimal length under the problem constraint.
[code]
int currlen = 0;
int currSum = 0;
bool foundAns = false;       // yic  for no ans case
int j = 0;

for (int i = 0; i <nums.Length; i++)
{
    while (j < nums.Length && currSum < s)
    {
        currSum += nums[j++];
        currlen++;
    }

    if (currSum >= s)
    {
        foundAns = true;
        minLen = Math.Min(minLen, currlen);

        // now i can move forward
        currlen--;
        currSum -= nums[i];
    }
}

/// 590
/// http://www.lintcode.com/en/problem/connecting-graph-ii/
/// Given n nodes in a graph labeled from 1 to n. There is no edges in the graph at beginning.
///
///    You need to support the following method:
///1. connect(a, b), an edge to connect node a and node b
///2. query(a), Returns the number of connected component nodes which include node a.
/// </summary>
public class ConnectingGraph2
{
    int[] ufArray;
    int[] countArray;
	int componentsCount;

    public ConnectingGraph2(int n)
    {
        ufArray = new int[n];    // store parent and count
        countArray = new int[n];
        for (int i = 0; i<n; i++)
        {
            ufArray[i] = i;     // parent loc to itself
            countArray[i] = 1;    // count
        }
		this.componentsCount = n;
    }

    private int Find(int x)
    {
        if (x != ufArray[x])
        {
            int topAncestor = Find(ufArray[x]);
            ufArray[x] = topAncestor;
        }

        return ufArray[x];
    }

    public void connect(int a, int b)
    {
        int rootA = Find(a);
        int rootB = Find(b);

        if (rootA != rootB)
        {
            ufArray[rootB] = rootA;
            countArray[rootA] += countArray[rootB];  // dump the rootB count to RootA

			componentsCount--;
        }
    }

    public int query(int a)
    {
        int rootA = Find(a);
        return countArray[rootA];

		//return  componentsCount;
    }
}
-----------------------------
public class UnionFindAccont
{
    Dictionary<string, string> unionLookup;

    public UnionFindAccont(HashSet<string> emails)
    {
        unionLookup = new Dictionary<string, string>();
        foreach (var email in emails)
        {
            unionLookup.Add(email, email);
        }
    }

    public string Find(string email)
    {
        if (email != unionLookup[email])
        {
            var ancestor = Find(unionLookup[email]);
            unionLookup[email] = ancestor;
        }
        return unionLookup[email];
    }

    public void Union(string email1, string email2)
    {
        // yic use find  
        string p1 = Find(email1);
        string p2 = Find(email2);

        if (p1 != p2)
        {
            //  yic use p2, not email
            unionLookup[p2] = p1;
        }
    }
}




/// Trie
class Node
{
public bool hasWord { get; set; }
public Node[] children { get; set; }

public Node()
{
    children = new Node[26];  //You may assume that all inputs are consist of lowercase letters a-z.
    hasWord = false;
}
}

class Trie
{
        

private Node root;

public Trie()
{
    root = new Node();
}

/*
    * @param word: a word
    * @return: nothing
    */
public void insert(String word)
{
    Node curr = root;

    foreach(char c in word)
    {
        if (curr.children[c - 'a'] == null)
        {
            curr.children[c - 'a'] = new Node(); 
        }

        curr = curr.children[c - 'a'];
    }

    curr.hasWord = true;
}

/*
    * @param word: A string
    * @return: if the word is in the trie.
    */
public bool search(String word)
{
    Node curr = root;

    foreach (char c in word)
    {
        if (curr.children[c-'a'] == null)
        {
            return false;
        }
        curr = curr.children[c - 'a'];
    }

    return curr.hasWord;

}

/*
    * @param prefix: A string
    * @return: if there is any word in the trie that starts with the given prefix.
    */
public bool startsWith(String prefix)
{
    Node curr = root;

    foreach (char c in prefix)
    {
        if (curr.children[c - 'a'] == null)
        {
            return false;
        }
        curr = curr.children[c - 'a'];
    }

    return true;
}